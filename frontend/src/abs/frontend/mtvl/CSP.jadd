import java.util.Collection;
import java.util.ArrayList;
import abs.frontend.mtvl.ChocoSolver;
import org.chocosolver.solver.*;
import org.chocosolver.solver.constraints.Constraint;
import org.chocosolver.solver.variables.*;

/**
Builds constraints and solve them.
Checks type errors, and if all variables are properly declared.
 **/

aspect CSP {
	refine ProductFlattener public void Model.flattenForProduct(ProductDecl prod, boolean check) throws WrongProgramArgumentException,DeltaModellingException {
        if (check && hasMTVL()) {
            java.util.List<String> errors = instantiateCSModel().checkSolutionWithErrors(prod.getProduct().getSolution(), this);
            if (!errors.isEmpty()) {
                String msg = "Product [" + prod.getName() + "] does not satisfy the feature model. Constraints failed:";
                for (String s: errors)
                    msg = msg + "\n- " + s;
                throw new WrongProgramArgumentException(msg);
            }
        }
        /* call original: */
        refined(prod,check);  
    }
    
    public ChocoSolver Model.instantiateCSModel() {
        ChocoSolver solver = new ChocoSolver(this);
		
		// new int variable for all int variables
        /*for (java.util.Map.Entry<String, BoundaryInt[]> entry : ints().entrySet()) {
            String st = entry.getKey();
            if (entry.getValue().length == 2) {
                BoundaryInt b1 = entry.getValue()[0];
                BoundaryInt b2 = entry.getValue()[1];
                solver.addBoundedVar(st, b1, b2);
            }
            else {
                solver.addSetVar(st, entry.getValue());
            }
        }*/
        for (String st : bools())
            solver.addBoolVar(st);
        for (String name : features())
            solver.addBoolVar(name);

        collectConstraints(solver);
        
        return solver;
    }
	
	public ChocoSolver Model.instantiateCSModelFeaturesOnly() {
        ChocoSolver solver = new ChocoSolver(this);

        for (String st : features())
            solver.addBoolVar(st);

        collectConstraints(solver);
        return solver;
    }
    
    public void Model.dropAttributes() {
        // ints and bools store integer and boolean (feature) attributes. Need to be ran twice to be the same collection. 
        ints();
        ints().clear();
        bools();
        bools().clear();
        for (CompilationUnit c: getCompilationUnits())
            c.dropAttributes();
    }

    public void CompilationUnit.dropAttributes() {
        for (FeatureDecl f: getFeatureDecls())
            f.dropAttributes();
        for (FExt f: getFExts())
            f.dropAttributes();
    }

    public void FeatureDecl.dropAttributes() {
        List<Constr> constrs = getAttrConstraints().getConstrs();
        for (int i = constrs.getNumChildNoTransform()-1; i>=0; i--) {
            if (constrs.getChild(i).hasAttributes())
                constrs.removeChild(i);
        }
        if (hasGroup())
            for (FNode f: getGroup().getFNodes())
                f.getFeatureDecl().dropAttributes();
    }

    public void FExt.dropAttributes() {
        List<Constr> constrs = getAttrConstraints().getConstrs();
        for (int i = constrs.getNumChildNoTransform()-1; i>=0; i--) {
            if (constrs.getChild(i).hasAttributes())
                constrs.removeChild(i);
        }
        if (hasGroup())
            for (FNode f: getGroup().getFNodes())
                f.getFeatureDecl().dropAttributes();
    }

    public boolean Constr.hasAttributes() { return true; }
    public boolean Exclude.hasAttributes() { return false; }
    public boolean Require.hasAttributes() { return false; }

    // GENERAL NODE: propagate
    public Constraint ASTNode.collectConstraints(ChocoSolver s) {
        for(int i = 0; i < getNumChild(); i++)
            getChildNoTransform(i).collectConstraints(s);
            
        return s.model.trueConstraint();
    }

    // ROOT: has to be present
    public Constraint CompilationUnit.collectConstraints(ChocoSolver s) {
        for (int i = 0; i < getNumFeatureDecl(); i++) {
            s.forceTrue(getFeatureDecl(i).getName());
        }
        super.collectConstraints(s);
        
        return s.model.trueConstraint();
    }

    public void Group.includeGroupConstraints(ChocoSolver s, String varName) {
        IntVar fvar = s.getVar(varName);
        int nfeats = getNumFNode();
        String fname = "";
        IntVar[] feats = new IntVar[nfeats];
        
        for (int i = 0; i < nfeats; i++) {
            fname = getFNode(i).getFeatureDecl().getName();
            IntVar v = null;
            // add intermediate variable $f if f is optional.
            if (getFNode(i) instanceof OptFeat) {
                v = s.model.boolVar("$"+fname, true);
                // f -> $f
     			s.model.ifThen(s.model.arithm(s.getVar(fname), "=", 1), s.model.arithm(v, "=", 1));
            } else {
                v = s.getVar(fname);
            }
            // f -> fparent
            s.model.ifThen(s.model.arithm(v, "=", 1), s.model.arithm(fvar, "=", 1));
            // rec - FNode
            s.addConstraint(getFNode(i).collectConstraints(s));
            feats[i] = v;
            // f -> $f /\ f -> fparent /\ [f]
        }
        // n1 <= $f1 + ... + $fn <= n2
        if (getCard() instanceof AllOf)
            // f ->  #feats = nfeats
            s.model.ifThen(s.model.arithm(fvar, "=", 1), s.model.sum(feats, "=", nfeats));
        else if (getCard() instanceof Minim)
            // f ->  #feats >= from
            s.model.ifThen(s.model.arithm(fvar, "=", 1), s.model.sum(feats, ">=", nfeats));
        else {
            // f ->  to >= #feats >= from
            s.model.ifThen(s.model.arithm(fvar, "=", 1), s.model.sum(feats, ">=", ((CRange) getCard()).getCFrom()));
            s.model.ifThen(s.model.arithm(fvar, "=", 1), s.model.sum(feats, "<=", ((CRange) getCard()).getCTo()));
        }
    }

    // FEATURE -> collect constraints, check cardinality, and check children.
    public Constraint FeatureDecl.collectConstraints(ChocoSolver s) {
        AttrConstraints acl = getAttrConstraints();
        for(int i = 0; i < acl.getNumConstr(); i++)
            s.addConstraint(acl.getConstr(i).collectConstraints(s));

        if (hasGroup())
            getGroup().includeGroupConstraints(s, getName());
            
        return s.model.trueConstraint();
    }

    // FNODE
    public Constraint FNode.collectConstraints(ChocoSolver s) {
        return getFeatureDecl().collectConstraints(s);
    }

    // FExt
    public Constraint FExt.collectConstraints(ChocoSolver s) {
        AttrConstraints acl = getAttrConstraints();
        for(int i = 0; i < acl.getNumConstr(); i++)
            s.addConstraint(acl.getConstr(i).collectConstraints(s));

        if (hasGroup())
            getGroup().includeGroupConstraints(s,getName());

        return s.model.trueConstraint();
    }

    // IFIN/IFOUT
    public Constraint IfIn.collectConstraints(ChocoSolver s) {
        s.model.ifThen(s.model.arithm(s.getVar(pname()), "=", 1), getExpr().collectConstraints(s));
        return s.model.trueConstraint();
    }
    public Constraint IfOut.collectConstraints(ChocoSolver s) {
        s.model.ifThen(s.model.not(s.model.arithm(s.getVar(pname()), "=", 1)), getExpr().collectConstraints(s));
        return s.model.trueConstraint();
    } 

    // REQUIRE/EXCLUDE
    public Constraint Require.collectConstraints(ChocoSolver s) {
        s.model.ifThen(s.model.arithm(s.getVar(pname()), "=", 1), s.model.arithm(s.getVar(getFeatVar().getFName()), "=", 1));
        return s.model.trueConstraint();
    } 
    public Constraint Exclude.collectConstraints(ChocoSolver s) {
        Constraint c = s.model.not(s.model.and(s.getVar(pname()), s.getVar(getFeatVar().getFName())));
        return c;
    } 

    // EXPRESSIONS
    // EXP: GENERAL (always overwritten when the program type-checks)
    public Constraint MExp.collectConstraints(ChocoSolver s) {
        return null;
    }
    /*public IntegerExpressionVariable MExp.collectIntExpr(ChocoSolver s) {
        return null;
    }*/
    
    // EXP:VARS
    public Constraint Variable.collectConstraints(ChocoSolver s) {
        return s.model.arithm(s.getVar(getFullName()), "=", 1);
    }
    /*public IntVar Variable.collectIntExpr(ChocoSolver s) {
        return s.getVar(getFullName());
    }*/

    //EXP:VALUES
    public Constraint MValue.collectConstraints(ChocoSolver s) {
        return getValue().collectConstraints(s);
    }
    /*public IntVar MValue.collectIntExpr(ChocoSolver s) {
        return getValue().collectIntExpr(s);
    }*/
    
    // null is overwritten always for well-typed elements
    public Constraint Value.collectConstraints(ChocoSolver s) {return null;}
    //public IntVar Value.collectIntExpr(ChocoSolver s) {return null;}

    public Constraint BoolVal.collectConstraints(ChocoSolver s) {
        if (getValue()) 
            return s.model.trueConstraint();
        else            
            return s.model.falseConstraint();
    }
    /*public IntVar IntVal.collectIntExpr(ChocoSolver s) {
        return Choco.constant(getValue());
    }*/

    // EXP: AddExp
    /*public IntegerExpressionVariable MAddAddExp.collectIntExpr(ChocoSolver s) {
        return Choco.plus(getLeft().collectIntExpr(s), getRight().collectIntExpr(s));
    }
    public IntegerExpressionVariable MSubAddExp.collectIntExpr(ChocoSolver s) {
        return Choco.minus(getLeft().collectIntExpr(s), getRight().collectIntExpr(s));
    }*/

    // EXP: MultExp
    /*public IntegerExpressionVariable MMultMultExp.collectIntExpr(ChocoSolver s) {
        return Choco.mult(getLeft().collectIntExpr(s), getRight().collectIntExpr(s));
    }
    public IntegerExpressionVariable MDivMultExp.collectIntExpr(ChocoSolver s) {
        return Choco.div(getLeft().collectIntExpr(s), getRight().collectIntExpr(s));
    }
    public IntegerExpressionVariable MModMultExp.collectIntExpr(ChocoSolver s) {
        return Choco.mod(getLeft().collectIntExpr(s), getRight().collectIntExpr(s));
    }*/

    // EXP: Unary
    /*public IntegerExpressionVariable MMinusExp.collectIntExpr(ChocoSolver s) {
        return Choco.neg(getOperand().collectIntExpr(s));
    }*/
    public Constraint MNegExp.collectConstraints(ChocoSolver s) {
        return s.model.not(getOperand().collectConstraints(s));
    }

    // EXP: EqualityExpr
    public Constraint MEqExp.collectConstraints(ChocoSolver s) {
        // Need to type check JUST the equality of expressions, to know if the constraints should produce  '==' or '<->'.
        // All other type checking should be done after flattening. 
        checkType(Types.BOOL, new SemanticConditionList());
        if (isInt)
            //return s.model.arithm(getLeft().collectIntExpr(s), "=", getRight().collectIntExpr(s));
        	return s.model.trueConstraint();
        else
            s.model.ifOnlyIf(getLeft().collectConstraints(s), getRight().collectConstraints(s));
            
        return null;    
    }

    // EXP: RelationalExpr
    public Constraint MGTEQExp.collectConstraints(ChocoSolver s) {
    	//return s.model.arithm(getLeft().collectIntExpr(s), ">=", getRight().collectIntExpr(s));
    	return s.model.trueConstraint();
    }
    public Constraint MLTEQExp.collectConstraints(ChocoSolver s) {
    	//return s.model.arithm(getLeft().collectIntExpr(s), "<=", getRight().collectIntExpr(s));
    	return s.model.trueConstraint();
    }
    public Constraint MGTExp.collectConstraints(ChocoSolver s) {
    	//return s.model.arithm(getLeft().collectIntExpr(s), ">", getRight().collectIntExpr(s));
    	return s.model.trueConstraint();
    }
    public Constraint MLTExp.collectConstraints(ChocoSolver s) {
    	//return s.model.arithm(getLeft().collectIntExpr(s), "<", getRight().collectIntExpr(s));
    	return s.model.trueConstraint();
    }

    // EXP: BoolExp
    public Constraint MEquivExp.collectConstraints(ChocoSolver s) {
        s.model.ifOnlyIf(getLeft().collectConstraints(s), getRight().collectConstraints(s));
        return s.model.trueConstraint();
    }
    public Constraint MImpliesExp.collectConstraints(ChocoSolver s) {
        s.model.ifThen(getLeft().collectConstraints(s), getRight().collectConstraints(s));
        return s.model.trueConstraint();    
    }
    public Constraint MOrBoolExp.collectConstraints(ChocoSolver s) {
    	Constraint[] cnstrs = new Constraint[2];
    	cnstrs[0] = getLeft().collectConstraints(s); 
    	cnstrs[1] = getRight().collectConstraints(s);
    	
        return s.model.or(cnstrs);
    }
    public Constraint MAndBoolExp.collectConstraints(ChocoSolver s) {
    	Constraint[] cnstrs = new Constraint[2];
    	cnstrs[0] = getLeft().collectConstraints(s); 
    	cnstrs[1] = getRight().collectConstraints(s);
        
        return s.model.and(cnstrs);
    }
}
