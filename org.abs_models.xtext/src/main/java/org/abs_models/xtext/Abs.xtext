grammar org.abs_models.xtext.Abs hidden(WS,ML_COMMENT,SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate abs "http://www.abs_models.org/xtext/Abs"

CompilationUnit
    : {CompilationUnit} (modules+=ModuleDecl)* (deltas+=DeltaDecl)*
        productline=ProductlineDecl?
        products+=ProductDecl*
        ( root_features+=MTVLFeatureRoot
        | feature_extensions+=MTVLFeatureExtension)*
    ;

ModuleDecl
    : 'module' name=QualifiedTypeIdentifier ';'
        (exports+=ModuleExport | imports+=ModuleImport)*
        (declarations+=Declaration)*
        ( main_annotations=Annotations main?='{' (mainblockstmts+=Stmt)* '}')?
    ;

ModuleExport
    : 'export'
        ( star?='*' | identifiers+=AnyIdentifier (',' identifiers+=AnyIdentifier)*)
        ( 'from' modulename=QualifiedTypeIdentifier )?
        ';'
    ;

ModuleImport
    : 'import'
        (( star?='*' 'from' modulename=QualifiedTypeIdentifier )
        | (identifiers+=AnyIdentifier (',' identifiers+=AnyIdentifier)*
                ( 'from' modulename=QualifiedTypeIdentifier )?
            ))
        ';'
    ;

// Annotations

Annotation: (id=TYPE_IDENTIFIER ':')? value=Exp ;

Annotations: {Annotations} ( '[' annotations+=Annotation (',' annotations+=Annotation)* ']')* ;

// Declarations

Declaration
    : DataTypeDecl
    | TypeSynonymDecl
    | ExceptionDecl
    | FunctionDecl
    | TraitDecl
    | InterfaceDecl
    | ClassDecl
    ;

DataTypeDecl
    : annotations=Annotations 'data' name=TYPE_IDENTIFIER
        ('<' typeparams+=TYPE_IDENTIFIER (',' typeparams+=TYPE_IDENTIFIER)* '>')?
        ('=' constructors+=DataConstructorDecl ('|' constructors+=DataConstructorDecl)* )?
        ';'
    ;

DataConstructorDecl : name=TYPE_IDENTIFIER ('(' args+=DataConstructorParamDecl (',' args+=DataConstructorParamDecl)* ')')? ;

DataConstructorParamDecl : type=TypeUse (name=IDENTIFIER)? ;

TypeSynonymDecl : annotations=Annotations 'type' name=TYPE_IDENTIFIER '=' type=TypeUse ';' ;

ExceptionDecl
    : annotations=Annotations 'exception' name=TYPE_IDENTIFIER
        ('(' args+=DataConstructorParamDecl (',' args+=DataConstructorParamDecl)* ')')? ';'
    ;

FunctionDecl
    : annotations=Annotations 'def' resulttype=TypeUse name=IDENTIFIER
        ('<' typeparams+=TYPE_IDENTIFIER (',' typeparams+=TYPE_IDENTIFIER)* '>')?
        ( '(' (function_args+=IDENTIFIER (',' function_args+=IDENTIFIER)*)? ')')?
        '(' (args+=ParamDecl (',' args+=ParamDecl)* )? ')'
        '=' (builtin?='builtin' | body=Exp)
        ';'
    ;

TraitDecl : 'trait' name=TYPE_IDENTIFIER '=' trait_exp=TraitExp ;

TraitExp : basic_exp=BasicTraitExp trait_ops+=TraitOp* ;

BasicTraitExp
    : MethodSet?='{' methods+=MethodDecl* '}'
    | methods+=MethodDecl
    | ref=TYPE_IDENTIFIER
    ;

TraitOp
    : 'removes'
        ( RemoveMethodModifier?='{' ( removed_sigs+=MethodSignature ';' )* '}'
        | removed_sigs+=MethodSignature ';' )
    | 'adds' added_exp=BasicTraitExp
    | 'modifies' modified_exp=BasicTraitExp
    ;

InterfaceDecl
    : annotations=Annotations 'interface' name=TYPE_IDENTIFIER
        ('extends' superinterfaces+=QualifiedTypeIdentifier (',' superinterfaces+=QualifiedTypeIdentifier)* )?
        '{' (methods+=MethodSignature ';' )* '}'
    ;

MethodSignature
    : annotations=Annotations resulttype=TypeUseNoAnnotations name=IDENTIFIER
        '(' ( args+=ParamDecl (',' args+=ParamDecl)* )? ')'
    ;

ClassDecl
    : annotations=Annotations 'class' name=TYPE_IDENTIFIER
        ( '(' ( args+=ParamDecl (',' args+=ParamDecl)* )? ')' )?
        ( 'implements' interfaces+=QualifiedTypeIdentifier (',' interfaces+=QualifiedTypeIdentifier)* )?
        '{'
        (fields+=FieldDecl ';')*
        ( '{' initblockstmts+=Stmt* '}' )?
        ( 'recover' '{' (recoverbranches+=CaseStmtBranch)* '}' )?
        ( 'uses' used_traits+=TraitExp ';' )*
        (methods+=MethodDecl)*
        '}'
    ;

FieldDecl
    : annotations=Annotations type=TypeUseNoAnnotations name=IDENTIFIER
        (hasInit?='=' init=Exp)?
    ;

MethodDecl
    : annotations=Annotations resulttype=TypeUseNoAnnotations name=IDENTIFIER
        // Our JastAdd AST has an embedded MethodSig inside MethodDecl while
        // in xtext we just parse name etc. directly.  `sig_end_position' is
        // used to calculate the end location of that embedded node.
        '(' (args+=ParamDecl (',' args+=ParamDecl)* )? sig_end_position=')'
        '{' (statements+=Stmt)* '}'
    ;

ParamDecl : annotations=Annotations type=TypeUseNoAnnotations name=IDENTIFIER ;

// Statements

Stmt : Annotations
        ( {VarDeclStmt.annotations=current}
            type=TypeUseNoAnnotations name=IDENTIFIER ( '=' init=Exp )? ';'
        | {AssignStmt.annotations=current}
            lhs=VarOrFieldExp '=' exp=Exp ';'
        | {SkipStmt.annotations=current}
             'skip' ';'
        | {ReturnStmt.annotations=current}
            'return' exp=Exp ';'
        | {AssertStmt.annotations=current}
            'assert' exp=Exp ';'
        | {Block.annotations=current}
            '{' (stmts+=Stmt)* '}'
        | {IfStmt.annotations=current}
            'if' '(' condition=Exp ')' consequence=Stmt (=>'else' alternate=Stmt)?
        | {WhileStmt.annotations=current}
            'while' '(' condition=Exp ')' body=Stmt
        | {ForeachStmt.annotations=current}
            'foreach' '(' loopvar=IDENTIFIER 'in' list=Exp ')' body=Stmt
        | {TryCatchFinallyStmt.annotations=current}
            'try' body=Stmt
            'catch' (( '{' (branches+=CaseStmtBranch)* '}') | branches+=CaseStmtBranch)
            (=> 'finally' finally=Stmt)?
        // await is parsed as an expression; this way we catch both "await
        // o!m()" and "await f?;" in one syntax rule.  We disallow certain
        // combinations of guards in validation -- see AbsValidator.checkSideEffectExpressionAllowed, AbsValidator.checkNoMethodCallInSubguard.
        | {SuspendStmt.annotations=current}
            'suspend' ';'
        | {DurationStmt.annotations=current}
            'duration' '(' min=Exp ',' max=Exp ')' ';'
        | {ThrowStmt.annotations=current}
            'throw' exception=Exp ';'
        | {DieStmt.annotations=current}
            'die' exception=Exp ';'
        | {MoveCogToStmt.annotations=current}
            'movecogto' target=Exp ';'
        | {ExpStmt.annotations=current}
            exp=Exp ';'
        | {CaseStmt.annotations=current}
            'switch' '(' condition=Exp ')' '{' (branches+=CaseStmtBranch)* '}'
        )
    ;

Guard : AndGuard ;

AndGuard returns Guard
    : SingleGuard ({AndGuard.left=current} '&' right=SingleGuard)*
    ;

SingleGuard returns Guard
    : {ExpGuard} exp=Exp claim?='?'?
    | {DurationGuard} 'duration' '(' min=Exp ',' max=Exp ')'
    ;

CaseStmtBranch : pattern=Pattern '=>' body=Stmt ;

Pattern
    : {WildcardPattern} '_'
    | {IntLiteralPattern} value=INTLITERAL
    | {StringLiteralPattern} value=STRINGLITERAL
    | {FloatLiteralPattern} value=FLOATLITERAL
    | {VariablePattern} value=IDENTIFIER
    | {ConstructorPattern} name=QualifiedTypeIdentifier ( '(' (args+=Pattern (',' args+=Pattern)* )? ')' )?
    ;

// Expressions

// KLUDGE: I did not manage to express the separation of side-effect and pure
// expressions in the Xtext parser in the way that antlr4 did it -- having
// PureExp as prefixes in GetExp, AsyncCallExp and SyncCallExp did not lead to
// compile-time warnings for these expressions but mis-parsed them
// nevertheless.

// KLUDGE: the expression grammar fragment is not LL(2) (although
// Exp by itself is) -- we turned on backtracking in
// `GenerateAbs.mwe2' for now.
// TODO: check if this is still necessary now that we merged EffExp and PureExp
Exp
    : OrExp
    ;

// See http://www.eclipse.org/Xtext/documentation/307_special_languages.html#expressions

OrExp returns Exp
    : AndExp ({OrExp.left=current} '||' right=AndExp)*
    ; // left-assoc

AndExp returns Exp
    : EqExp ({AndExp.left=current} '&&' right=EqExp)*
    ; // left-assoc

EqExp returns Exp
    : CompareExp
        (( {EqExp.left=current} '=='
         | {NotEqExp.left=current} '!=')
        right=CompareExp)?
    ; // non-assoc

CompareExp returns Exp
    : PlusMinusExp
        (( {LTExp.left=current} '<'
         | {GTExp.left=current} '>'
         | {LTEQExp.left=current} '<='
         | {GTEQExp.left=current} '>=')
        right=PlusMinusExp)?
    ; // non-assoc

PlusMinusExp returns Exp
    : MulDivModExp
        (( {PlusExp.left=current} '+'
         | {MinusExp.left=current} '-')
        right=MulDivModExp)*
    ; // left-assoc

MulDivModExp returns Exp
    : MethodCallExp
        (( {MulExp.left=current} '*'
         | {DivExp.left=current}'/'
         | {ModExp.left=current} '%')
        right=MethodCallExp)*
    ; // left-assoc

MethodCallExp returns Exp
// "await o!m()" is parsed as an AwaitExp with an ExpGuard containing a
// MethodCallExp instead of a MethodCallExp with an "await" prefix -- see also
// AbsValidator where we filter out invalid syntaxes, and XtextToJastAdd where
// we disambiguate between AwaitStmt and AwaitAsyncCall; the code there is not
// pretty.
//
// But: “In general, a good practice in Xtext DSL implementations is to keep
// the grammar simple.  It is better to have a loose grammar and a strict
// validation phase (loose grammar, strict validation, see the presentation
// Zarnekow 2012).” (Bettini 2016, pg. 207)
    : GetExp ({MethodCallExp.target=current} operator=('!' | '.') methodname=IDENTIFIER '(' (args+=Exp ( ',' args+=Exp)* )? ')' )?
    ;

GetExp returns Exp
    : ConversionExp ({GetExp.futureExp=current} '.' 'get' )?
    ;

ConversionExp returns Exp
    : PrimaryExp
        (( {ImplementsExp.body=current} 'implements'
         | {AsExp.body=current} 'as' )
        interface=QualifiedTypeIdentifier )?
    ;

PrimaryExp returns Exp
    :  '(' Exp ')'
    | UnaryExp
    | AwaitExp
    | NewExp
    | OriginalCallExp
    | CaseExp
    | LetExp
    | IfExp
    | FunctionAppExp
    | VariadicFunctionAppExp
    | ConstructorAppExp
    | TemplateStringExp
    | AtomicExp
    ;

UnaryExp returns Exp
    : ( '!' PrimaryExp {NotExp.body=current}
      | '-' PrimaryExp {NegExp.body=current}
      // | '+' Exp {PosExp.body=current}
    )
    ;

AwaitExp returns Exp : {AwaitExp} 'await' guard=Guard ;

NewExp returns Exp :
        {NewExp} 'new' (local?='local')? classname=QualifiedTypeIdentifier '('  (args+=Exp ( ',' args+=Exp)* )? ')'
    ;

OriginalCallExp returns Exp : {OriginalCallExp} (( delta=TYPE_IDENTIFIER | core?='core' ) '.')? 'original' '(' (args+=Exp ( ',' args+=Exp)* )? ')' ;

CaseExp returns Exp
    : {CaseExp} 'case' condition=Exp '{' (casebranches+=CaseExpBranch)* '}'
    ;

CaseExpBranch
    : pattern=Pattern '=>' expression=Exp ';'
    ;

LetExp returns Exp
    : {LetExp} 'let' '('? variables+=ParamDecl ')'? '=' exps+=Exp
        (',' '('? variables+=ParamDecl ')'? '=' exps+=Exp)*
        'in' body=Exp
    ;

IfExp returns Exp
    : {IfExp} 'when' condition=Exp 'then' consequence=Exp 'else' alternate=Exp
    ;

FunctionAppExp returns Exp
    : {FunctionAppExp} name=QualifiedIdentifier
        ( '(' functionArgs+=PartialFunctionParam (',' functionArgs+=PartialFunctionParam )* ')' )?
        '(' (args+=Exp ( ',' args+=Exp)* )? ')'
    ;

PartialFunctionParam
    : name=QualifiedIdentifier
    | '(' ( params+=ParamDecl (',' params+=ParamDecl)* )? ')' "=>" body=Exp
    ;

VariadicFunctionAppExp returns Exp
    : {VariadicFunctionAppExp} name=QualifiedIdentifier '[' (args+=Exp ( ',' args+=Exp)* )? ']'
    ;

ConstructorAppExp returns Exp
    : {ConstructorAppExp} name=QualifiedTypeIdentifier ( '(' ( args+=Exp ( ',' args+=Exp)* )? ')' )?
    ;

TemplateStringExp returns Exp
    : {TemplateStringSimpleExp} string=TEMPLATESTRINGLITERAL
    | {TemplateStringExp} startString=TEMPLATESTRINGSTART firstExp=Exp
        (betweenStrings+=TEMPLATESTRINGINBETWEEN exps+=Exp)*
        endString=TEMPLATESTRINGEND
    ;

AtomicExp returns Exp
    : {IntLiteral} value=INTLITERAL
    | {FloatLiteral} value=FLOATLITERAL
    | {StringLiteral} value=STRINGLITERAL
    | VarOrFieldExp
    | {ThisExp} 'this'
    | {NullLiteral} 'null'
    ;

VarOrFieldExp returns Exp
    : {VarOrFieldExp} (field?='this' '.')? name=IDENTIFIER
    ;

// Types

TypeUse : annotations=Annotations type=TypeUseNoAnnotations ;

// We use TypeUseNoAnnotations for parameters and methods so
// annotations are parsed as part of the method / parameter, not its
// type.
TypeUseNoAnnotations
    : name=QualifiedTypeIdentifier
        ('<' params+=TypeUse (',' params+=TypeUse)* '>')?
    ;

// Terminals

terminal ML_COMMENT : '/*' -> '*/';
terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS: (' '|'\t'|'\r'|'\n')+;

terminal fragment SMALLLETTER : 'a'..'z' ;
terminal fragment CAPITALLETTER : 'A'..'Z' ;

terminal DIGIT : '0'..'9' ;

// "Note: It is generally not a good idea to implement floating point literals
// with terminal rules. You should use data type rules instead due to possible
// shadowing problems explained above."
// https://www.eclipse.org/Xtext/documentation/301_grammarlanguage.html

// But if we use a datatype rule, 'e' and 'E' become reserved words and,
// hence, unavailable as variable names.  Just be careful to define floats
// before ints so they don't get shadowed by the greedy lexer.
terminal FLOATLITERAL returns ecore::EDouble
    : DIGIT* '.' DIGIT+ (("e" | "E" | "e+" | "E+" | "e-" | "E-") DIGIT+)?
    ;

terminal INTLITERAL returns ecore::EBigInteger : DIGIT+ ;

terminal STRINGLITERAL
    : '"' ( '\\' ('"' | '\\' | 't' | 'n' | 'r') | !('"' | '\\'))* '"'
    ;

terminal fragment TEMPLATESTRING_INNER
    : '\\' ('`' | '$')
    | !('`' | '$')
    ;

terminal TEMPLATESTRINGLITERAL : '`' TEMPLATESTRING_INNER* '`' ;

terminal TEMPLATESTRINGSTART
    : '`' TEMPLATESTRING_INNER* '$'
    ;

terminal TEMPLATESTRINGINBETWEEN
    : '$' TEMPLATESTRING_INNER* '$'
    ;
terminal TEMPLATESTRINGEND
    : '$' TEMPLATESTRING_INNER* '`'
    ;


terminal IDENTIFIER : SMALLLETTER (CAPITALLETTER|SMALLLETTER|'_'|DIGIT)* ;

terminal TYPE_IDENTIFIER : CAPITALLETTER (CAPITALLETTER|SMALLLETTER|'_'|DIGIT)* ;

QualifiedIdentifier returns ecore::EString : (TYPE_IDENTIFIER '.')* IDENTIFIER ;
QualifiedTypeIdentifier returns ecore::EString : (TYPE_IDENTIFIER '.')* TYPE_IDENTIFIER ;

AnyIdentifier returns ecore::EString
    : QualifiedIdentifier
    | QualifiedTypeIdentifier
    ;

// ========== end of Core ABS ==========

// Deltas

DeltaDecl
    : 'delta' name=TYPE_IDENTIFIER
        ( '(' ( args+=DeltaParamDecl (',' args+=DeltaParamDecl)* )? ')' )?
        ';'
        // TODO: multiple in the antlr grammar but the AST only supports one
        // instance of this
        ('uses' usedModulenames+=QualifiedTypeIdentifier ';')*
        (modifiers+=DeltaModuleModifier)*
    ;

DeltaParamDecl
    : normalParam=ParamDecl
    | ( classModifier=QualifiedTypeIdentifier condition=DeltaCondition )
    ;

DeltaCondition
    : 'hasField' deltaFieldCondition=FieldDecl
    | 'hasMethod' deltaMethodCondition=MethodSignature
    | 'hasInterface' deltaInterfaceCondition=QualifiedTypeIdentifier
    ;

DeltaModuleModifier
    : 'adds'
        ( added_decl=Declaration
        | added_import=ModuleImport
        | added_export=ModuleExport)
    | 'removes'
        ( 'class' removed_class_name=QualifiedTypeIdentifier ';'
        | 'interface' removed_interface_name=QualifiedTypeIdentifier ';')
    | 'modifies'
        ( 'class' modified_class_name=QualifiedTypeIdentifier
            ('adds' added_interfaces+=QualifiedTypeIdentifier
                (',' added_interfaces+=QualifiedTypeIdentifier)*)?
            ('removes' removed_interfaces+=QualifiedTypeIdentifier
                (',' removed_interfaces+=QualifiedTypeIdentifier)*)?
            '{' (class_modifiers+=ClassModifier)* '}'
        | 'interface' modified_interface_name=QualifiedTypeIdentifier
            '{' (interface_modifiers+=InterfaceModifier)* '}'
        | modified_typesyn=TypeSynonymDecl
        | modified_datatype=DataTypeDecl
        )
    ;

ClassModifier
    : 'adds'
        ( added_field=FieldDecl ';'
        | '{' added_methods+=MethodDecl* '}'
        | added_methods+=MethodDecl
        | added_trait=TYPE_IDENTIFIER)
    | 'removes'
        ( removed_field=FieldDecl ';'
        | '{' ( removed_methods+=MethodSignature ';' )* '}'
        | removed_methods+=MethodSignature ';' )
    | 'modifies'
        ( modified_methods+=MethodDecl
        | '{' modified_methods+=MethodDecl* '}'
        | modified_trait=TYPE_IDENTIFIER
        )
    ;

InterfaceModifier
    : 'adds' addedMethod=MethodSignature ';'
    | 'removes' removedMethod=MethodSignature ';'
    ;

// Productline

ProductlineDecl
    : 'productline' name=TYPE_IDENTIFIER ';'
        'features' features+=ProductFeature (',' features+=ProductFeature)* ';'
        delta_clauses+=ProductlineDeltaClause*
    ;

ProductFeature
// allow writing Feat' to refer to the intermediate feature "$feat"
    : name=TYPE_IDENTIFIER p?='\''?
        ('{' attribute_assignments+=AttributeAssignment (',' attribute_assignments+=AttributeAssignment)* '}')?
    ;

AttributeAssignment : name=IDENTIFIER '=' value = AttributeAssignmentValue ;

AttributeAssignmentValue
    : {AttributeAssignmentValue_Int} value=INTLITERAL
    | {AttributeAssignmentValue_Bool} value=TYPE_IDENTIFIER
    | {AttributeAssignmentValue_String} value=STRINGLITERAL
    ;

ProductlineDeltaClause
    : 'delta' name=TYPE_IDENTIFIER
        ('(' params+=DeltaClauseParam (',' params+=DeltaClauseParam)* ')')?
        ('after' after_ids+=TYPE_IDENTIFIER (',' after_ids+=TYPE_IDENTIFIER)* )?
        ('from' from_condition=DeltaClauseApplicationClause)?
        (('when' | 'to') when_condition=DeltaClauseApplicationClause)?
        ';'
    ;

DeltaClauseParam
// CID | FID.aid | CONSTANT
// The following comment copied from ABS.g4, which copied from ABS.parser:
// TODO: accept feature, attributes, or constants (DataExp)
    : {DeltaClauseParam_Int} int_param=INTLITERAL
    | {DeltaClauseParam_Id} id_param=TYPE_IDENTIFIER ('.' fidaid_param=IDENTIFIER)?
    ;

DeltaClauseApplicationClause : DeltaClauseApplicationClauseOr ;

DeltaClauseApplicationClauseOr returns DeltaClauseApplicationClause
    : DeltaClauseApplicationClauseAnd ({DeltaClauseApplicationClauseOr.left = current} '||' right=DeltaClauseApplicationClauseAnd)* ;

DeltaClauseApplicationClauseAnd returns DeltaClauseApplicationClause
    : DeltaClauseApplicationClausePrimary ({DeltaClauseApplicationClauseAnd.left = current} '&&' right=DeltaClauseApplicationClausePrimary)* ;

DeltaClauseApplicationClausePrimary returns DeltaClauseApplicationClause
    : '!' not=DeltaClauseApplicationClausePrimary
    | '(' paren=DeltaClauseApplicationClause ')'
    | feature_name=TYPE_IDENTIFIER
    ;

// Products

ProductDecl
    : 'product' name=TYPE_IDENTIFIER
        ( '(' ( features+=ProductFeature (',' features+=ProductFeature)* )? ')' ';'
        | '=' expr=ProductExpr ';' )
    ;

ProductExpr : ProductExprDifference ;

ProductExprDifference returns ProductExpr
    : ProductExprUnion ({ProductExprDifference.left = current} '-' right=ProductExprUnion)*
    ;

ProductExprUnion returns ProductExpr
    : ProductExprIntersect ({ProductExprUnion.left = current} '||' right=ProductExprIntersect)*
    ;

ProductExprIntersect returns ProductExpr
    : ProductExprPrimary ({ProductExprIntersect.left = current} '&&' right=ProductExprPrimary)*
    ;

ProductExprPrimary returns ProductExpr
    : '{' features+=ProductFeature (',' features+=ProductFeature)* '}'
    | prodname=TYPE_IDENTIFIER
    | '(' paren=ProductExpr ')'
    ;

// Feature Model


// The following rules are translations of the corresponding antlr rules and
// differ from the grammar in the manual in some places.
MTVLFeatureRoot
    : 'root' name=TYPE_IDENTIFIER
        (
            '{'
            group=MTVLFeatureGroup?
            (attributes+=MTVLAttributeDecl | constraints+=MTVLConstraint)*
            '}'
        )?
    ;

MTVLFeatureDecl
// same as MTVLFeatureRoot without the ’root’ keyword in front
    : name=TYPE_IDENTIFIER
        (
            '{'
            group=MTVLFeatureGroup?
            (attributes+=MTVLAttributeDecl | constraints+=MTVLConstraint)*
            '}'
        )?
    ;

MTVLFeatureExtension
    : 'extension' name=TYPE_IDENTIFIER
        '{'
        group=MTVLFeatureGroup?
        (attributes+=MTVLAttributeDecl | constraints+=MTVLConstraint)*
        '}'
    ;

MTVLFeatureGroup
    : 'group'
        ( allof?='allof'
        | oneof?='oneof'
        | '[' lower=INTLITERAL '..' upper=MTVLIntLimit ']'
        )
        '{'
        children+=MTVLChildFeature (',' children+=MTVLChildFeature)*
        '}'
    ;

MTVLChildFeature : opt?='opt'? feature=MTVLFeatureDecl ;

MTVLAttributeDecl
    : type=TYPE_IDENTIFIER name=IDENTIFIER
        ('in'
            ( interval?='[' lower=MTVLIntLimit '..' upper=MTVLIntLimit ']'
            | set?='{' content+=MTVLIntValue (',' content+=MTVLIntValue)* '}')
        )?
        ';'
    ;

MTVLIntLimit : star?='*' | minus?='-'? value=INTLITERAL ;

MTVLIntValue : minus?='-'? value=INTLITERAL ;

MTVLConstraint returns MTVLConstraint
    : 'ifin' {MTVLIfInConstraint} ':' expr=MTVLConstraintExpr ';'
    | 'ifout' {MTVLIfOutConstraint} ':' expr=MTVLConstraintExpr ';'
    | 'require' {MTVLRequireConstraint} ':' require=TYPE_IDENTIFIER ';'
    | 'exclude' {MTVLExcludeConstraint} ':' exclude=TYPE_IDENTIFIER ';'
    | {MTVLIfInConstraint} expr=MTVLConstraintExpr ';'
    ;

MTVLConstraintExpr : MTVLConstraintExprOr ;

MTVLConstraintExprOr returns MTVLConstraintExpr
    : MTVLConstraintExprAnd ({MTVLConstraintExprOr.left=current} '||' right=MTVLConstraintExprAnd)*
    ; // left-assoc

MTVLConstraintExprAnd returns MTVLConstraintExpr
    : MTVLConstraintExprImplEqv ({MTVLConstraintExprAnd.left=current} '&&' right=MTVLConstraintExprImplEqv)*
    ; // left-assoc

MTVLConstraintExprImplEqv returns MTVLConstraintExpr
    : MTVLConstraintExprEqNeq
        ( ({MTVLConstraintExprImpl.left=current} '->' right=MTVLConstraintExprEqNeq)
        | ({MTVLConstraintExprEqv.left=current} '<->' right=MTVLConstraintExprEqNeq))?
    ; // non-assoc

MTVLConstraintExprEqNeq returns MTVLConstraintExpr
    : MTVLConstraintExprCompare
        ( ({MTVLConstraintExprEq.left=current} '==' right=MTVLConstraintExprCompare)
        | ({MTVLConstraintExprNeq.left=current} '!=' right=MTVLConstraintExprCompare))?
    ; // non-assoc

MTVLConstraintExprCompare returns MTVLConstraintExpr
    : MTVLConstraintExprPlusMinus
        ( ({MTVLConstraintExprLT.left=current} '<' right=MTVLConstraintExprPlusMinus)
        | ({MTVLConstraintExprGT.left=current} '>' right=MTVLConstraintExprPlusMinus)
        | ({MTVLConstraintExprLTEQ.left=current} '<=' right=MTVLConstraintExprPlusMinus)
        | ({MTVLConstraintExprGTEQ.left=current} '>=' right=MTVLConstraintExprPlusMinus))?
    ; // non-assoc

MTVLConstraintExprPlusMinus returns MTVLConstraintExpr
    : MTVLConstraintExprMulDivMod
      ( ({MTVLConstraintExprPlus.left=current} '+' right=MTVLConstraintExprMulDivMod)
        | ({MTVLConstraintExprMinus.left=current} '-' right=MTVLConstraintExprMulDivMod))*
    ; // left-assoc

MTVLConstraintExprMulDivMod returns MTVLConstraintExpr
    : MTVLConstraintExprPrimary
      ( ({MTVLConstraintExprMul.left=current} '*' right=MTVLConstraintExprPrimary)
        | ({MTVLConstraintExprDiv.left=current} '/' right=MTVLConstraintExprPrimary)
        | ({MTVLConstraintExprMod.left=current} '%' right=MTVLConstraintExprPrimary))*
    ; // left-assoc

MTVLConstraintExprPrimary returns MTVLConstraintExpr
    : '(' paren_exp=MTVLConstraintExpr ')'
    | '-' minus_exp=MTVLConstraintExprPrimary
    | '!' neg_exp=MTVLConstraintExprPrimary
    | int_exp=INTLITERAL
    | id_exp=IDENTIFIER
    | type_exp=TYPE_IDENTIFIER (dot?='.' dot_id=IDENTIFIER)?
    ;

// Local Variables:
// mode: antlr
// End:
