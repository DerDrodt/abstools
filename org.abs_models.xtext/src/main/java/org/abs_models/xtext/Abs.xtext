grammar org.abs_models.xtext.Abs hidden(WS,ML_COMMENT,SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate abs "http://www.abs_models.org/xtext/Abs"

CompilationUnit
    : {CompilationUnit} (modules+=ModuleDecl)*
    ;

ModuleDecl
    : 'module' name=QualifiedTypeIdentifier ';'
        (exports+=ModuleExport | imports+=ModuleImport)*
        (declarations+=Declaration)*
        ( '{' (mainblockstmts+=Stmt)* '}')?
    ;

ModuleExport
    : 'export'
        ( star?='*' | identifiers+=AnyIdentifier (',' identifiers+=AnyIdentifier)*)
        ( 'from' modulename=QualifiedTypeIdentifier )?
        ';'
    ;

ModuleImport
    : 'import'
        (( star?='*' 'from' modulename=QualifiedTypeIdentifier )
        | (identifiers+=AnyIdentifier (',' identifiers+=AnyIdentifier)*
                ( 'from' modulename=QualifiedTypeIdentifier )?
            ))
        ';'
    ;


// Annotations

Annotation: (id=TYPE_IDENTIFIER ':')? value=Exp ;

Annotations: {Annotations} ( '[' annotations+=Annotation (',' annotations+=Annotation)* ']')* ;

// Declarations

Declaration
    : DataTypeDecl
    | TypeSynonymDecl
    | ExceptionDecl
    | FunctionDecl
    | PartialFunctionDecl
    | InterfaceDecl
    | ClassDecl
    // | TraitDecl
    ;

DataTypeDecl
    : annotations=Annotations 'data' name=TYPE_IDENTIFIER
        ('<' typeparams+=TYPE_IDENTIFIER (',' typeparams+=TYPE_IDENTIFIER)* '>')?
        ('=' constructors+=DataConstructorDecl ('|' constructors+=DataConstructorDecl)* )?
        ';'
    ;

DataConstructorDecl : name=TYPE_IDENTIFIER ('(' args+=DataConstructorParamDecl (',' args+=DataConstructorParamDecl)* ')')? ;

DataConstructorParamDecl : type=TypeUse (name=IDENTIFIER)? ;

TypeSynonymDecl : annotations=Annotations 'type' name=TYPE_IDENTIFIER '=' type=TypeUse ';' ;

ExceptionDecl
    : annotations=Annotations 'exception' name=TYPE_IDENTIFIER
        ('(' args+=DataConstructorParamDecl (',' args+=DataConstructorParamDecl)* ')')? ';'
    ;

FunctionDecl
    : annotations=Annotations 'def' resulttype=TypeUse name=IDENTIFIER
        ('<' typeparams+=TYPE_IDENTIFIER (',' typeparams+=TYPE_IDENTIFIER)* '>')?
        '(' (args+=ParamDecl (',' args+=ParamDecl)* )? ')'
        '=' (builtin?='builtin' | body=Exp)
        ';'
    ;

PartialFunctionDecl
    : annotations=Annotations 'def' resulttype=TypeUse name=IDENTIFIER
        ('<' typeparams+=TYPE_IDENTIFIER (',' typeparams+=TYPE_IDENTIFIER)* '>')?
        '(' function_args+=IDENTIFIER (',' function_args+=IDENTIFIER)* ')'
        '(' args+=ParamDecl (',' args+=ParamDecl)* ')'
        '=' body=Exp
        ';'
    ;

InterfaceDecl
    : annotations=Annotations 'interface' name=TYPE_IDENTIFIER
        ('extends' superinterfaces+=QualifiedTypeIdentifier (',' superinterfaces+=QualifiedTypeIdentifier)* )?
        '{' (methods+=MethodSignature)* '}'
    ;

MethodSignature
    : annotations=Annotations resulttype=TypeUseNoAnnotations name=IDENTIFIER
        '(' ( args+=ParamDecl (',' args+=ParamDecl)* )? ')'
        ';'
    ;

ClassDecl
    : annotations=Annotations 'class' name=TYPE_IDENTIFIER
        ( '(' args+=ParamDecl (',' args+=ParamDecl)* ')' )?
        ( 'implements' interfaces+=QualifiedTypeIdentifier (',' interfaces+=QualifiedTypeIdentifier)* )?
        '{'
        (fields+=FieldDecl)*
        ( '{' initblockstmts+=Stmt* '}' )?
        ( 'recover' '{' (recoverbranches+=CaseStmtBranch)* '}' )?
        // (traits+=TraitUsage)*
        (methods+=MethodDecl)*
        '}'
    ;

FieldDecl
    : annotations=Annotations type=TypeUseNoAnnotations name=IDENTIFIER
        (hasInit?='=' init=Exp)? ';'
    ;

MethodDecl
    : annotations=Annotations resulttype=TypeUseNoAnnotations name=IDENTIFIER
        '(' (args+=ParamDecl (',' args+=ParamDecl)* )? ')'
        '{' (statements+=Stmt)* '}'
    ;

ParamDecl : annotations=Annotations type=TypeUseNoAnnotations name=IDENTIFIER ;

// Statements

Stmt : Annotations
        ( {VarDeclStmt.annotations=current}
            type=TypeUseNoAnnotations name=IDENTIFIER ( '=' init=Exp )? ';'
        | {AssignStmt.annotations=current}
            lhs=VarOrFieldExp '=' exp=Exp ';'
        | {SkipStmt.annotations=current}
             'skip' ';'
        | {ReturnStmt.annotations=current}
            'return' exp=Exp ';'
        | {AssertStmt.annotations=current}
            'assert' exp=Exp ';'
        | {Block.annotations=current}
            '{' (stmts+=Stmt)* '}'
        | {IfStmt.annotations=current}
            'if' '(' condition=Exp ')' consequence=Stmt (=>'else' alternate=Stmt)?
        | {WhileStmt.annotations=current}
            'while' '(' condition=Exp ')' body=Stmt
        | {ForeachStmt.annotations=current}
            'foreach' '(' var=IDENTIFIER 'in' list=Exp ')' body=Stmt
        | {TryCatchFinallyStmt.annotations=current}
            'try' body=Stmt
            'catch' (( '{' (branches+=CaseStmtBranch)* '}') | branches+=CaseStmtBranch)
            (=> 'finally' finally=Stmt)?
        | {AwaitStmt.annotations=current}
            'await' guard=Guard ';'
        | {SuspendStmt.annotations=current}
            'suspend' ';'
        | {DurationStmt.annotations=current}
            'duration' '(' min=Exp ',' max=Exp ')' ';'
        | {ThrowStmt.annotations=current}
            'throw' exception=Exp ';'
        | {DieStmt.annotations=current}
            'die' exception=Exp ';'
        | {MoveCogToStmt.annotations=current}
            'movecogto' target=Exp ';'
        | {ExpStmt.annotations=current}
            exp=Exp ';'
        | {CaseStmt.annotations=current}
            'switch' '(' condition=Exp ')' '{' (branches+=CaseStmtBranch)* '}'
        )
    ;

Guard : SingleGuard ({Guard.left=current} '&' right=SingleGuard)* ;

SingleGuard returns Guard
    : ClaimGuard
    | DurationGuard
    | ExpGuard
    ;

ClaimGuard returns Guard : exp=VarOrFieldExp '?' ;

DurationGuard returns Guard :  'duration' '(' min=Exp ',' max=Exp ')' ;

ExpGuard returns Guard : exp=Exp ;

CaseStmtBranch : pattern=Pattern '=>' body=Stmt ;

// Expressions

// KLUDGE: I did not manage to express the separation of side-effect and pure
// expressions in the Xtext parser in the way that antlr4 did it -- having
// PureExp as prefixes in GetExp, AsyncCallExp and SyncCallExp did not lead to
// compile-time warnings for these expressions but mis-parsed them
// nevertheless.

// KLUDGE: the expression grammar fragment is not LL(2) (although
// Exp by itself is) -- we turned on backtracking in
// `GenerateAbs.mwe2' for now.
// TODO: check if this is still necessary now that we merged EffExp and PureExp
Exp
    : OrExp
    ;

NewExp returns Exp : {NewExp} 'new' (hasLocal?='local')? classname=QualifiedTypeIdentifier '('  (args+=Exp ( ',' args+=Exp)* )? ')' ;

OriginalCallExp returns Exp : {OriginalCallExp} (( delta=TYPE_IDENTIFIER | core?='core' ) '.')? 'original' '(' (args+=Exp ( ',' args+=Exp)* )? ')' ;

// See http://www.eclipse.org/Xtext/documentation/307_special_languages.html#expressions

CaseExp returns Exp
    : {CaseExp} 'case' condition=Exp '{' (casebranches+=CaseExpBranch)* '}'
    ;

CaseExpBranch
    : pattern=Pattern '=>' expression=Exp ';'
    ;

Pattern
    : {WildcardPattern} '_'
    | {IntLiteralPattern} value=INTLITERAL
    | {StringLiteralPattern} value=STRINGLITERAL
    | {FloatLiteralPattern} value=FLOATLITERAL
    | {VariablePattern} value=IDENTIFIER
    | {ConstructorPattern} name=QualifiedTypeIdentifier ( '(' args+=Pattern (',' args+=Pattern)* ')' )?
    ;

LetExp returns Exp
    : {LetExp} 'let' '('? variables+=ParamDecl ')'? '=' exps+=Exp
        (',' '('? variables+=ParamDecl ')'? '=' exps+=Exp)*
        'in' body=Exp
    ;

IfExp returns Exp
    : {IfExp} 'when' condition=Exp 'then' consequence=Exp 'else' alternate=Exp
    ;

FunctionAppExp returns Exp
    : {FunctionAppExp} name=QualifiedIdentifier '(' (args+=Exp ( ',' args+=Exp)* )? ')'
    ;

VariadicFunctionAppExp returns Exp
    : {VariadicFunctionAppExp} name=QualifiedIdentifier '[' (args+=Exp ( ',' args+=Exp)* )? ']'
    ;

PartialFunctionAppExp returns Exp
    : {PartialFunctionAppExp} name=QualifiedIdentifier
        '(' function_args+=PartialFunctionParam (',' function_args+=PartialFunctionParam )* ')'
        '(' (args+=Exp ( ',' args+=Exp)* )? ')'
    ;

PartialFunctionParam
    : name=QualifiedIdentifier
    | '(' params+=ParamDecl (',' params+=ParamDecl)* ')' "=>" body=Exp
    ;

ConstructorAppExp returns Exp
    : {ConstructorAppExp} name=QualifiedTypeIdentifier ( '(' args+=Exp ( ',' args+=Exp)* ')' )?
    ;

TemplateStringExp returns Exp
    : {TemplateStringExp} TEMPLATESTRINGLITERAL
    | {TemplateStringExp} TEMPLATESTRINGSTART e1=Exp
        (b+=TEMPLATESTRINGINBETWEEN e+=Exp)*
        TEMPLATESTRINGEND
    ;

OrExp returns Exp
    : AndExp ({OrExp.left=current} '||' right=AndExp)*
    ; // left-assoc

AndExp returns Exp
    : EqExp ({AndExp.left=current} '&&' right=EqExp)*
    ; // left-assoc

EqExp returns Exp
    : CompareExp ({EqExp.left=current} operator=('==' | '!=') right=CompareExp)?
    ; // non-assoc

CompareExp returns Exp
    : PlusMinusExp ({CompareExp.left=current} operator=('<' | '>' | '<=' | '>=') right=PlusMinusExp)?
    ; // non-assoc

PlusMinusExp returns Exp
    : MulDivModExp ({PlusMinusExp.left=current} operator=('+' | '-') right=MulDivModExp)*
    ; // left-assoc

MulDivModExp returns Exp
    : UnaryExp ({MulDivExp.left=current} operator=('*' | '/' | '%') right=UnaryExp)*
    ; // left-assoc

UnaryExp returns Exp
    : {UnaryExp} operator=('!' | '-' | '+') body=UnaryExp
    | MethodCallExp
    ;

MethodCallExp returns Exp
    : {MethodCallExp} await?='await'? target=GetExp operator=('!' | '.') methodname=IDENTIFIER '(' (args+=Exp ( ',' args+=Exp)* )? ')'
    | GetExp
    ;

GetExp returns Exp
    : {GetExp} future=PrimaryExp '.get'
    | ConversionExp
    ;

ConversionExp returns Exp
    : PrimaryExp ({ConversionExp.body=current} operator=('implements' | 'as') i=QualifiedTypeIdentifier )?
    ;

PrimaryExp returns Exp
    :  '(' Exp ')'
    | NewExp
    | OriginalCallExp
    | CaseExp
    | LetExp
    | IfExp
    | FunctionAppExp
    | VariadicFunctionAppExp
    | PartialFunctionAppExp
    | ConstructorAppExp
    | TemplateStringExp
    | AtomicExp
    ;

AtomicExp returns Exp
    : {IntLiteral} value=INTLITERAL
    | {FloatLiteral} value=FLOATLITERAL
    | {StringLiteral} value=STRINGLITERAL
    | VarOrFieldExp
    | {ThisExp} 'this'
    | {NullLiteral} 'null'
    ;

VarOrFieldExp returns Exp
    : {VarOrFieldExp} (hasThis?='this' '.')? name=IDENTIFIER
    ;

// Types

TypeUse : annotations=Annotations type=TypeUseNoAnnotations ;

// We use TypeUseNoAnnotations for parameters and methods so
// annotations are parsed as part of the method / parameter, not its
// type.
TypeUseNoAnnotations
    : name=QualifiedTypeIdentifier
        ('<' params+=TypeUse (',' params+=TypeUse)* '>')?
    ;

// Terminals

terminal ML_COMMENT : '/*' -> '*/';
terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS: (' '|'\t'|'\r'|'\n')+;

terminal fragment SMALLLETTER : 'a'..'z' ;
terminal fragment CAPITALLETTER : 'A'..'Z' ;

terminal DIGIT : '0'..'9' ;

// "Note: It is generally not a good idea to implement floating point literals
// with terminal rules. You should use data type rules instead due to possible
// shadowing problems explained above."
// https://www.eclipse.org/Xtext/documentation/301_grammarlanguage.html

// But if we use a datatype rule, 'e' and 'E' become reserved words and,
// hence, unavailable as variable names.  Just be careful to define floats
// before ints so they don't get shadowed by the greedy lexer.
terminal FLOATLITERAL returns ecore::EDouble
    : DIGIT* '.' DIGIT+ (("e" | "E" | "e+" | "E+" | "e-" | "E-") DIGIT+)?
    ;

terminal INTLITERAL returns ecore::EBigInteger : DIGIT+ ;

terminal STRINGLITERAL
    : '"' ( '\\' ('"' | '\\' | 't' | 'n' | 'r') | !('"' | '\\'))* '"'
    ;

terminal fragment TEMPLATESTRING_INNER
    : '\\' ('`' | '$')
    | !('`' | '$')
    ;

terminal TEMPLATESTRINGLITERAL : '`' TEMPLATESTRING_INNER* '`' ;

terminal TEMPLATESTRINGSTART
    : '`' TEMPLATESTRING_INNER* '$'
    ;

terminal TEMPLATESTRINGINBETWEEN
    : '$' TEMPLATESTRING_INNER* '$'
    ;
terminal TEMPLATESTRINGEND
    : '$' TEMPLATESTRING_INNER* '`'
    ;


terminal IDENTIFIER : SMALLLETTER (CAPITALLETTER|SMALLLETTER|'_'|DIGIT)* ;

terminal TYPE_IDENTIFIER : CAPITALLETTER (CAPITALLETTER|SMALLLETTER|'_'|DIGIT)* ;

QualifiedIdentifier returns ecore::EString : (TYPE_IDENTIFIER '.')* IDENTIFIER ;
QualifiedTypeIdentifier returns ecore::EString : (TYPE_IDENTIFIER '.')* TYPE_IDENTIFIER ;

AnyIdentifier returns ecore::EString
    : QualifiedIdentifier
    | QualifiedTypeIdentifier
    ;

// Local Variables:
// mode: antlr
// End:
