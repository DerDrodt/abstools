grammar org.abs_models.xtext.Abs hidden(WS,ML_COMMENT,SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate abs "http://www.abs_models.org/xtext/Abs"

CompilationUnit
    : {CompilationUnit} (module+=ModuleDecl)*
    ;

ModuleDecl
    : 'module' name=QualifiedTypeIdentifier ';'
        (modeExportImport+=ModuleExportImport)*
        // (decl+=Decl)*
        (mainBlock=Block)?
    ;

ModuleExportImport
    : ModuleExport
    | ModuleImport
    ;

ModuleExport
    : 'export' (hasStar?='*' 'from' module=QualifiedTypeIdentifier
        | name+=AnyIdentifier (',' name+=AnyIdentifier)*)
        ('from' module=QualifiedTypeIdentifier)?
        ';'
    ;

ModuleImport
    : 'import' (hasStar?='*' 'from' module=QualifiedTypeIdentifier
        | name+=AnyIdentifier (',' name+=AnyIdentifier)* 'from' module=QualifiedTypeIdentifier
        | name+=AnyIdentifier (',' name+=AnyIdentifier)*)
        ';'
    ;


// Declarations

ParamDecl
    :
        // TODO annotations
        type=Type name=IDENTIFIER
    ;

// Statements

Stmt
    : VarDeclStmt
    | AssignStmt
    | SkipStmt
    | ReturnStmt
    | AssertStmt
    | Block
    | IfStmt
    | WhileStmt
    | ForeachStmt
    | TryCatchFinallyStmt
    | AwaitStmt
    | SuspendStmt
    | DurationStmt
    | ThrowStmt
    | DieStmt
    | MoveCogToStmt
    | ExpStmt
    | CaseStmt
    ;

VarDeclStmt : type=Type name=IDENTIFIER ( hasInit?='=' init=Exp )? ';' ;

AssignStmt : var=VarOrFieldExp '=' exp=Exp ';' ;

SkipStmt : {SkipStmt} 'skip' ';' ;

ReturnStmt : 'return' exp=Exp ';' ;

AssertStmt : 'assert' exp=Exp ';' ;

Block : '{' (stmt+=Stmt)* '}' ;

IfStmt : 'if' '(' condition=PureExp ')' consequence=Stmt (=>'else' alternate=Stmt) ;

WhileStmt : 'while' '(' condition=PureExp ')' body=Stmt ;

ForeachStmt : 'foreach' '(' var=IDENTIFIER 'in' list=PureExp ')' body=Stmt ;

TryCatchFinallyStmt
    : 'try' body=Stmt
        'catch' (( '{' (branches+=CaseStmtBranch)* '}') | branches+=CaseStmtBranch)
        ('finally' finally=Stmt)?
    ;

AwaitStmt : 'await' guard=Guard ';' ;

Guard : SingleGuard ({Guard.left=current} '&' right=SingleGuard)* ;

SingleGuard returns Guard
    : ClaimGuard
    | DurationGuard
    | ExpGuard
    ;

ClaimGuard returns Guard : exp=VarOrFieldExp '?' ;

DurationGuard returns Guard :  'duration' '(' min=PureExp ',' max=PureExp ')' ;

ExpGuard returns Guard : exp=PureExp ;

SuspendStmt : {SuspendStmt} 'suspend' ';' ;

DurationStmt : 'duration' '(' min=PureExp ',' max=PureExp ')' ;

ThrowStmt : 'throw' exception=PureExp ';' ;

DieStmt : 'die' exception=PureExp ';' ;

MoveCogToStmt : 'movecogto' target=PureExp ';' ;

ExpStmt : exp=Exp ';' ;

CaseStmt : 'case' condition=PureExp '{' (branches+=CaseStmtBranch)* '}' ;

CaseStmtBranch : p=Pattern '=>' body=PureExp ';' ;

// Expressions

// KLUDGE: the expression grammar fragment is not LL(2) (although
// PureExp by itself is) -- we turned on backtracking in
// `GenerateAbs.mwe2' for now.
Exp
    : PureExp
    | EffExp
    ;

EffExp
    : GetExp
    | NewExp
    | SyncCallExp
    | AsyncCallExp
    | AwaitAsyncCallExp
    | OriginalCallExp
    ;

GetExp : future=PureExp '.get' ;

NewExp : 'new' hasLocal?='local' c=QualifiedTypeIdentifier '('  args+=PureExp ( ',' args+=PureExp)* ')' ;

SyncCallExp : o=PureExp '.' m=IDENTIFIER '('  args+=PureExp ( ',' args+=PureExp)* ')' ;

AsyncCallExp : o=PureExp '!' m=IDENTIFIER '('  args+=PureExp ( ',' args+=PureExp)* ')' ;

AwaitAsyncCallExp : 'await' o=PureExp '!' m=IDENTIFIER '('  args+=PureExp ( ',' args+=PureExp)* ')' ;

OriginalCallExp : (( d=TYPE_IDENTIFIER | c?='core' ) '.')? 'original' '(' args+=PureExp ( ',' args+=PureExp)* ')' ;

PureExp
    : FunctionAppExp
    | VariadicFunctionAppExp
    | PartialFunctionAppExp
    | ConstructorAppExp
    | TemplateStringExp
    | LetExp
    | IfExp
    | CaseExp
    | OperatorExp
    ;

FunctionAppExp
    : name=QualifiedIdentifier '(' args+=PureExp ( ',' args+=PureExp)* ')'
    ;

VariadicFunctionAppExp
    : name=QualifiedIdentifier '[' args+=PureExp ( ',' args+=PureExp)* ']'
    ;

PartialFunctionAppExp
    : name=QualifiedIdentifier
        '(' fnargs+=PartialFunctionParam (',' fnargs+=PartialFunctionParam )* ')'
        '(' args+=PureExp ( ',' args+=PureExp)* ')'
    ;

PartialFunctionParam
    : name=QualifiedIdentifier
    | '(' params+=ParamDecl (',' params+=ParamDecl)* ')' "=>" body=PureExp
    ;

ConstructorAppExp
    : name=QualifiedTypeIdentifier ( '(' args+=PureExp ( ',' args+=PureExp)* ')' )?
    ;

TemplateStringExp
    : {TemplateStringExp} TEMPLATESTRINGLITERAL
    | TEMPLATESTRINGSTART e1=PureExp
        (b+=TEMPLATESTRINGINBETWEEN e+=PureExp)*
        TEMPLATESTRINGEND
    ;


LetExp
    : 'let' '(' param+=ParamDecl ')' '=' e+=PureExp
        (',' '(' param+=ParamDecl ')' '=' e+=PureExp)*
        'in' body=PureExp
    ;

IfExp
    : 'if' condition=PureExp 'then' consequence=PureExp 'else' alternate=PureExp
    ;

CaseExp
    : 'case' c=PureExp '{' (casebranch+=CaseExpBranch)* '}'
    ;

CaseExpBranch
    : p=Pattern '=>' e=PureExp ';'
    ;

Pattern
    : {WildcardPattern} '_'
    | {IntLiteralPattern} value=INTLITERAL
    | {StringLiteralPatern} value=STRINGLITERAL
    | {FloatLiteralPattern} value=FloatLiteral
    | {VariablePattern} value=IDENTIFIER
    | {ConstructorPattern} name=QualifiedTypeIdentifier ( '(' args+=Pattern (',' args+=Pattern)* ')' )?
    ;


// See http://www.eclipse.org/Xtext/documentation/307_special_languages.html#expressions

OperatorExp returns PureExp
    : body=OrExp (op=('implements' | 'as') i=QualifiedTypeIdentifier )?
    ;

OrExp returns PureExp
    : AndExp ({OrExp.left=current} '||' right=AndExp)*
    ; // left-assoc

AndExp returns PureExp
    : EqExp ({AndExp.left=current} '&&' right=EqExp)*
    ; // left-assoc

EqExp returns PureExp
    : CompareExp ({EqExp.left=current} op=('==' | '!=') right=CompareExp)?
    ; // non-assoc

CompareExp returns PureExp
    : PlusMinusExp ({CompareExp.left=current} op=('<' | '>' | '<=' | '>=') right=PlusMinusExp)?
    ; // non-assoc

PlusMinusExp returns PureExp
    : MulDivModExp ({PlusMinusExp.left=current} op=('+' | '-') right=MulDivModExp)*
    ; // left-assoc

MulDivModExp returns PureExp
    : UnaryExp ({MulDivExp.left=current} op=('*' | '/' | '%') right=UnaryExp)*
    ; // left-assoc

UnaryExp returns PureExp
    : '(' PureExp ')'
    | op=('!' | '-' | '+') body=UnaryExp
    | AtomicExp
    ;

AtomicExp returns PureExp
    : {IntLiteral} INTLITERAL
    | FloatLiteral
    | {StringLiteral} STRINGLITERAL
    | VarOrFieldExp
    | {ThisExp} 'this'
    | {NullLiteral} 'null'
    ;

VarOrFieldExp returns PureExp
    : (hasThis?='this' '.')? name=IDENTIFIER
    ;

// Types

Type
    // TODO
    : TYPE_IDENTIFIER
    ;

// Terminals

terminal ML_COMMENT : '/*' -> '*/';
terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS: (' '|'\t'|'\r'|'\n')+;

terminal fragment SMALLLETTER : 'a'..'z' ;
terminal fragment CAPITALLETTER : 'A'..'Z' ;

terminal DIGIT : '0'..'9' ;

INTLITERAL returns ecore::EInt : DIGIT+ ;

// "Note: It is generally not a good idea to implement floating point literals
// with terminal rules. You should use data type rules instead due to possible
// shadowing problems explained above."
// https://www.eclipse.org/Xtext/documentation/301_grammarlanguage.html
FloatLiteral returns ecore::EFloat
    : INTLITERAL? '.' DIGIT+ (('e' | 'E' | 'e+' | 'E+' | 'e-' | 'E-') DIGIT+)?
    ;

terminal STRINGLITERAL
    : '"' ( '\\' ('"' | '\\' | 't' | 'n' | 'r') | !('"' | '\\'))* '"'
    ;

terminal fragment TEMPLATESTRING_INNER
    : '\\' ('`' | '$')
    | !('`' | '$')
    ;

terminal TEMPLATESTRINGLITERAL : '`' TEMPLATESTRING_INNER* '`' ;

terminal TEMPLATESTRINGSTART
    : '`' TEMPLATESTRING_INNER* '$'
    ;

terminal TEMPLATESTRINGINBETWEEN
    : '$' TEMPLATESTRING_INNER* '$'
    ;
terminal TEMPLATESTRINGEND
    : '$' TEMPLATESTRING_INNER* '`'
    ;


terminal IDENTIFIER : SMALLLETTER (CAPITALLETTER|SMALLLETTER|'_'|DIGIT)* ;

terminal TYPE_IDENTIFIER : CAPITALLETTER (CAPITALLETTER|SMALLLETTER|'_'|DIGIT)* ;

QualifiedIdentifier returns ecore::EString : (TYPE_IDENTIFIER '.')* IDENTIFIER ;
QualifiedTypeIdentifier returns ecore::EString : (TYPE_IDENTIFIER '.')* TYPE_IDENTIFIER ;

AnyIdentifier returns ecore::EString
    : QualifiedIdentifier
    | QualifiedTypeIdentifier
    ;
