grammar org.abs_models.xtext.Abs hidden(WS,ML_COMMENT,SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate abs "http://www.abs_models.org/xtext/Abs"

CompilationUnit
    : {CompilationUnit} (module+=ModuleDecl)*
    ;

ModuleDecl
    : 'module' name=QualifiedTypeIdentifier ';'
        (modeExportImport+=ModuleExportImport)*
        // (decl+=Decl)*
        (mainBlock=Block)?
    ;

ModuleExportImport
    : ModuleExport
    | ModuleImport
    ;

ModuleExport
    : 'export' (star='*' 'from' module=QualifiedTypeIdentifier
        | name+=AnyIdentifier (',' name+=AnyIdentifier)*)
        ('from' module=QualifiedTypeIdentifier)?
        ';'
    ;

ModuleImport
    : 'import' (star='*' 'from' module=QualifiedTypeIdentifier
        | name+=AnyIdentifier (',' name+=AnyIdentifier)* 'from' module=QualifiedTypeIdentifier
        | name+=AnyIdentifier (',' name+=AnyIdentifier)*)
        ';'
    ;


// Declarations

ParamDecl
    :
        // TODO annotations
        type=Type name=IDENTIFIER
    ;

// Statements

Block
    : {Block} '{' (stmt+=Statement)* '}'
    ;

Statement
    : {Statement} SkipStmt
    | VarDeclStmt
    | Block
    ;

SkipStmt
    : 'skip' ';'
    ;

VarDeclStmt
    : type=Type name=IDENTIFIER ( '=' init=Exp )? ';'
    ;

// Expressions

Exp
    : PureExp
    // | EffExp
    ;

PureExp
    : FunctionAppExp
    | VariadicFunctionAppExp
    | PartialFunctionAppExp
    | ConstructorAppExp
    | TemplateStringExp
    | LetExp
    | IfExp
    | CaseExp
    | OperatorExp
    ;

FunctionAppExp
    : QualifiedIdentifier '(' args+=PureExp ( ',' args+=PureExp)* ')'
    ;

VariadicFunctionAppExp
    : QualifiedIdentifier '[' args+=PureExp ( ',' args+=PureExp)* ']'
    ;

PartialFunctionAppExp
    : QualifiedIdentifier
        '(' fnargs+=PartialFunctionParam (',' fnargs+=PartialFunctionParam )* ')'
        '(' args+=PureExp ( ',' args+=PureExp)* ')'
    ;

PartialFunctionParam
    : QualifiedIdentifier
    | '(' params+=ParamDecl (',' params+=ParamDecl)* ')' "=>" body=PureExp
    ;

ConstructorAppExp
    : QualifiedTypeIdentifier ( '(' args+=PureExp ( ',' args+=PureExp)* ')' )?
    ;

TemplateStringExp
    : {TemplateStringExp} TEMPLATESTRINGLITERAL
    | TEMPLATESTRINGSTART e1=PureExp
        (b+=TEMPLATESTRINGINBETWEEN e+=PureExp)*
        TEMPLATESTRINGEND
    ;


LetExp
    : 'let' '(' param+=ParamDecl ')' '=' e+=PureExp
        (',' '(' param+=ParamDecl ')' '=' e+=PureExp)*
        'in' body=PureExp
    ;

IfExp
    : 'if' condition=PureExp 'then' consequence=PureExp 'else' alternate=PureExp
    ;

CaseExp
    : 'case' c=PureExp '{' (casebranch+=CaseExpBranch)* '}'
    ;

CaseExpBranch
    : p=Pattern '=>' e=PureExp ';'
    ;

Pattern
    : {Pattern} '_'
    | INTLITERAL
    | STRINGLITERAL
    | FloatLiteral
    | IDENTIFIER
    | QualifiedTypeIdentifier ( '(' pattern+=Pattern (',' pattern+=Pattern)* ')' )?
    ;


// See http://www.eclipse.org/Xtext/documentation/307_special_languages.html#expressions

OperatorExp returns PureExp
    : body=OrExp (op=('implements' | 'as') i=QualifiedTypeIdentifier )?
    ;

OrExp returns PureExp
    : AndExp ({OrExp.left=current} '||' right=AndExp)*
    ; // left-assoc

AndExp returns PureExp
    : EqExp ({AndExp.left=current} '&&' right=EqExp)*
    ; // left-assoc

EqExp returns PureExp
    : CompareExp ({EqExp.left=current} op=('==' | '!=') right=CompareExp)?
    ; // non-assoc

CompareExp returns PureExp
    : PlusMinusExp ({CompareExp.left=current} op=('<' | '>' | '<=' | '>=') right=PlusMinusExp)?
    ; // non-assoc

PlusMinusExp returns PureExp
    : MulDivModExp ({PlusMinusExp.left=current} op=('+' | '-') right=MulDivModExp)*
    ; // left-assoc

MulDivModExp returns PureExp
    : UnaryExp ({MulDivExp.left=current} op=('*' | '/' | '%') right=UnaryExp)*
    ; // left-assoc

UnaryExp returns PureExp
    : '(' PureExp ')'
    | op=('!' | '-' | '+') body=UnaryExp
    | AtomicExp
    ;

AtomicExp returns PureExp
    : INTLITERAL
    | FloatLiteral
    | STRINGLITERAL
    | IDENTIFIER
    | 'this' '.' IDENTIFIER
    | 'this'
    | 'null'
    ;

// Types

Type
    // TODO
    : TYPE_IDENTIFIER
    ;

// Terminals

terminal ML_COMMENT : '/*' -> '*/';
terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS: (' '|'\t'|'\r'|'\n')+;

terminal fragment SMALLLETTER : 'a'..'z' ;
terminal fragment CAPITALLETTER : 'A'..'Z' ;

terminal DIGIT : '0'..'9' ;

INTLITERAL returns ecore::EInt : DIGIT+ ;

// "Note: It is generally not a good idea to implement floating point literals
// with terminal rules. You should use data type rules instead due to possible
// shadowing problems explained above."
// https://www.eclipse.org/Xtext/documentation/301_grammarlanguage.html
FloatLiteral returns ecore::EFloat
    : INTLITERAL? '.' DIGIT+ (('e' | 'E' | 'e+' | 'E+' | 'e-' | 'E-') DIGIT+)?
    ;

terminal STRINGLITERAL
    : '"' ( '\\' ('"' | '\\' | 't' | 'n' | 'r') | !('"' | '\\'))* '"'
    ;

terminal fragment TEMPLATESTRING_INNER
    : '\\' ('`' | '$')
    | !('`' | '$')
    ;

terminal TEMPLATESTRINGLITERAL : '`' TEMPLATESTRING_INNER* '`' ;

terminal TEMPLATESTRINGSTART
    : '`' TEMPLATESTRING_INNER* '$'
    ;

terminal TEMPLATESTRINGINBETWEEN
    : '$' TEMPLATESTRING_INNER* '$'
    ;
terminal TEMPLATESTRINGEND
    : '$' TEMPLATESTRING_INNER* '`'
    ;


terminal IDENTIFIER : SMALLLETTER (CAPITALLETTER|SMALLLETTER|'_'|DIGIT)* ;

terminal TYPE_IDENTIFIER : CAPITALLETTER (CAPITALLETTER|SMALLLETTER|'_'|DIGIT)* ;

QualifiedIdentifier returns ecore::EString : (TYPE_IDENTIFIER '.')* IDENTIFIER ;
QualifiedTypeIdentifier returns ecore::EString : (TYPE_IDENTIFIER '.')* TYPE_IDENTIFIER ;

AnyIdentifier returns ecore::EString
    : QualifiedIdentifier
    | QualifiedTypeIdentifier
    ;
