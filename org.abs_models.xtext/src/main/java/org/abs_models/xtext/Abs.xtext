grammar org.abs_models.xtext.Abs hidden(WS,ML_COMMENT,SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate abs "http://www.abs_models.org/xtext/Abs"

CompilationUnit
    : {CompilationUnit} (modules+=ModuleDecl)*
    ;

ModuleDecl
    : 'module' name=QualifiedTypeIdentifier ';'
        (modeExportImports+=ModuleExportImport)*
        (decls+=Decl)*
        (mainBlock=Block)?
    ;

ModuleExportImport
    : ModuleExport
    | ModuleImport
    ;

ModuleExport
    : 'export'
        ( star?='*' | names+=AnyIdentifier (',' names+=AnyIdentifier)*)
        ( 'from' module=QualifiedTypeIdentifier )?
        ';'
    ;

ModuleImport
    : 'import'
        ( star?='*' | names+=AnyIdentifier (',' names+=AnyIdentifier)*)
        ( 'from' module=QualifiedTypeIdentifier )?
        ';'
    ;


// Annotations

AnnotationFragment: (l=TYPE_IDENTIFIER ':')? r=Exp ;

Annotations: {Annotations} ( '[' a+=AnnotationFragment (',' a+=AnnotationFragment)* ']')* ;

// Declarations

Decl
    : DataTypeDecl
    | TypeSynonymDecl
    | ExceptionDecl
    | FunctionDecl
    | PartialFunctionDecl
    | InterfaceDecl
    | ClassDecl
    // | TraitDecl
    ;

DataTypeDecl
    : ann=Annotations 'data' name=TYPE_IDENTIFIER
        ('<' typeparams+=TYPE_IDENTIFIER (',' typeparams+=TYPE_IDENTIFIER)* '>')?
        ('=' constructors+=DataConstructorDecl ('|' constructors+=DataConstructorDecl)* )?
        ';'
    ;

DataConstructorDecl : name=TYPE_IDENTIFIER ('(' args+=DataConstructorParamDecl (',' args+=DataConstructorParamDecl)* ')')? ;

DataConstructorParamDecl : type=TypeUse (name=IDENTIFIER)? ;

TypeSynonymDecl : ann=Annotations 'type' name=TYPE_IDENTIFIER '=' type=TypeUse ';' ;

ExceptionDecl
    : ann=Annotations 'exception' name=TYPE_IDENTIFIER
        ('(' args+=DataConstructorParamDecl (',' args+=DataConstructorParamDecl)* ')')? ';'
    ;

FunctionDecl
    : ann=Annotations 'def' type=TypeUse name=IDENTIFIER
        ('<' typeparams+=TYPE_IDENTIFIER (',' typeparams+=TYPE_IDENTIFIER)* '>')?
        '(' (args+=ParamDecl (',' args+=ParamDecl)* )? ')'
        '=' (builtin?='builtin' | body=Exp)
        ';'
    ;

PartialFunctionDecl
    : ann=Annotations 'def' type=TypeUse name=IDENTIFIER
        ('<' typeparams+=TYPE_IDENTIFIER (',' typeparams+=TYPE_IDENTIFIER)* '>')?
        '(' function_args+=IDENTIFIER (',' function_args+=IDENTIFIER)* ')'
        '(' args+=ParamDecl (',' args+=ParamDecl)* ')'
        '=' body=Exp
        ';'
    ;

InterfaceDecl
    : ann=Annotations 'interface' name=TYPE_IDENTIFIER
        ('extends' superinterfaces+=QualifiedTypeIdentifier (',' superinterfaces+=QualifiedTypeIdentifier)* )?
        '{' (methods+=MethodSignature)* '}'
    ;

MethodSignature
    : ann=Annotations type=TypeUseNoAnnotations name=IDENTIFIER
        '(' ( args+=ParamDecl (',' args+=ParamDecl)* )? ')'
        ';'
    ;

ClassDecl
    : ann=Annotations 'class' name=TYPE_IDENTIFIER
        ( '(' args+=ParamDecl (',' args+=ParamDecl)* ')' )?
        ( 'implements' interfaces+=QualifiedTypeIdentifier (',' interfaces+=QualifiedTypeIdentifier)* )?
        '{'
        (fields+=FieldDecl)*
        (initblock=Block)?
        ( 'recover' '{' (recoverbranches+=CaseStmtBranch)* '}' )?
        // (traits+=TraitUsage)*
        (methods+=MethodDecl)*
        '}'
    ;

FieldDecl
    : ann=Annotations type=TypeUseNoAnnotations name=IDENTIFIER
        (hasInit?='=' init=Exp)? ';'
    ;

MethodDecl
    : ann=Annotations type=TypeUseNoAnnotations name=IDENTIFIER
        '(' (args+=ParamDecl (',' args+=ParamDecl)* )? ')'
        '{' (statements+=Stmt)* '}'
    ;

ParamDecl : ann=Annotations type=TypeUseNoAnnotations name=IDENTIFIER ;

// Statements

Stmt
    : VarDeclStmt
    | AssignStmt
    | SkipStmt
    | ReturnStmt
    | AssertStmt
    | Block
    | IfStmt
    | WhileStmt
    | ForeachStmt
    | TryCatchFinallyStmt
    | AwaitStmt
    | SuspendStmt
    | DurationStmt
    | ThrowStmt
    | DieStmt
    | MoveCogToStmt
    | ExpStmt
    | CaseStmt
    ;

VarDeclStmt : ann=Annotations type=TypeUseNoAnnotations name=IDENTIFIER ( '=' init=Exp )? ';' ;

AssignStmt : ann=Annotations lhs=VarOrFieldExp '=' exp=Exp ';' ;

SkipStmt : ann=Annotations 'skip' ';' ;

ReturnStmt : ann=Annotations 'return' exp=Exp ';' ;

AssertStmt : ann=Annotations 'assert' exp=Exp ';' ;

Block : ann=Annotations '{' (stmts+=Stmt)* '}' ;

IfStmt : ann=Annotations 'if' '(' condition=Exp ')' consequence=Stmt (=>'else' alternate=Stmt)? ;

WhileStmt : ann=Annotations 'while' '(' condition=Exp ')' body=Stmt ;

ForeachStmt : ann=Annotations 'foreach' '(' var=IDENTIFIER 'in' list=Exp ')' body=Stmt ;

TryCatchFinallyStmt
    : ann=Annotations
        'try' body=Stmt
        'catch' (( '{' (branches+=CaseStmtBranch)* '}') | branches+=CaseStmtBranch)
        ('finally' finally=Stmt)?
    ;

AwaitStmt : ann=Annotations 'await' guard=Guard ';' ;

Guard : SingleGuard ({Guard.left=current} '&' right=SingleGuard)* ;

SingleGuard returns Guard
    : ClaimGuard
    | DurationGuard
    | ExpGuard
    ;

ClaimGuard returns Guard : exp=VarOrFieldExp '?' ;

DurationGuard returns Guard :  'duration' '(' min=Exp ',' max=Exp ')' ;

ExpGuard returns Guard : exp=Exp ;

SuspendStmt : ann=Annotations 'suspend' ';' ;

DurationStmt : ann=Annotations 'duration' '(' min=Exp ',' max=Exp ')' ;

ThrowStmt : ann=Annotations 'throw' exception=Exp ';' ;

DieStmt : ann=Annotations 'die' exception=Exp ';' ;

MoveCogToStmt : ann=Annotations 'movecogto' target=Exp ';' ;

ExpStmt : ann=Annotations exp=Exp ';' ;

CaseStmt : ann=Annotations 'switch' '(' condition=Exp ')' '{' (branches+=CaseStmtBranch)* '}' ;

CaseStmtBranch : p=Pattern '=>' body=Stmt ;

// Expressions

// KLUDGE: I did not manage to express the separation of side-effect and pure
// expressions in the Xtext parser in the way that antlr4 did it -- having
// PureExp as prefixes in GetExp, AsyncCallExp and SyncCallExp did not lead to
// compile-time warnings for these expressions but mis-parsed them
// nevertheless.

// KLUDGE: the expression grammar fragment is not LL(2) (although
// Exp by itself is) -- we turned on backtracking in
// `GenerateAbs.mwe2' for now.
// TODO: check if this is still necessary now that we merged EffExp and PureExp
Exp
    : OrExp
    ;

NewExp : {NewExp} 'new' (hasLocal?='local')? c=QualifiedTypeIdentifier '('  (args+=Exp ( ',' args+=Exp)* )? ')' ;

OriginalCallExp : {OriginalCallExp} (( d=TYPE_IDENTIFIER | c?='core' ) '.')? 'original' '(' (args+=Exp ( ',' args+=Exp)* )? ')' ;

// See http://www.eclipse.org/Xtext/documentation/307_special_languages.html#expressions

CaseExp returns Exp
    : {CaseExp} 'case' c=Exp '{' (casebranches+=CaseExpBranch)* '}'
    ;

CaseExpBranch
    : p=Pattern '=>' e=Exp ';'
    ;

Pattern
    : {WildcardPattern} '_'
    | {IntLiteralPattern} value=INTLITERAL
    | {StringLiteralPatern} value=STRINGLITERAL
    | {FloatLiteralPattern} value=FLOATLITERAL
    | {VariablePattern} value=IDENTIFIER
    | {ConstructorPattern} name=QualifiedTypeIdentifier ( '(' args+=Pattern (',' args+=Pattern)* ')' )?
    ;

LetExp returns Exp
    : {LetExp} 'let' '('? variables+=ParamDecl ')'? '=' exps+=Exp
        (',' '('? variables+=ParamDecl ')'? '=' exps+=Exp)*
        'in' body=Exp
    ;

IfExp returns Exp
    : {IfExp} 'when' condition=Exp 'then' consequence=Exp 'else' alternate=Exp
    ;

FunctionAppExp returns Exp
    : {FunctionAppExp} name=QualifiedIdentifier '(' (args+=Exp ( ',' args+=Exp)* )? ')'
    ;

VariadicFunctionAppExp returns Exp
    : {VariadicFunctionAppExp} name=QualifiedIdentifier '[' (args+=Exp ( ',' args+=Exp)* )? ']'
    ;

PartialFunctionAppExp returns Exp
    : {PartialFunctionAppExp} name=QualifiedIdentifier
        '(' function_args+=PartialFunctionParam (',' function_args+=PartialFunctionParam )* ')'
        '(' (args+=Exp ( ',' args+=Exp)* )? ')'
    ;

PartialFunctionParam
    : name=QualifiedIdentifier
    | '(' params+=ParamDecl (',' params+=ParamDecl)* ')' "=>" body=Exp
    ;

ConstructorAppExp returns Exp
    : {ConstructorAppExp} name=QualifiedTypeIdentifier ( '(' args+=Exp ( ',' args+=Exp)* ')' )?
    ;

TemplateStringExp returns Exp
    : {TemplateStringExp} TEMPLATESTRINGLITERAL
    | TEMPLATESTRINGSTART e1=Exp
        (b+=TEMPLATESTRINGINBETWEEN e+=Exp)*
        TEMPLATESTRINGEND
    ;

OrExp returns Exp
    : AndExp ({OrExp.left=current} '||' right=AndExp)*
    ; // left-assoc

AndExp returns Exp
    : EqExp ({AndExp.left=current} '&&' right=EqExp)*
    ; // left-assoc

EqExp returns Exp
    : CompareExp ({EqExp.left=current} op=('==' | '!=') right=CompareExp)?
    ; // non-assoc

CompareExp returns Exp
    : PlusMinusExp ({CompareExp.left=current} op=('<' | '>' | '<=' | '>=') right=PlusMinusExp)?
    ; // non-assoc

PlusMinusExp returns Exp
    : MulDivModExp ({PlusMinusExp.left=current} op=('+' | '-') right=MulDivModExp)*
    ; // left-assoc

MulDivModExp returns Exp
    : UnaryExp ({MulDivExp.left=current} op=('*' | '/' | '%') right=UnaryExp)*
    ; // left-assoc

UnaryExp returns Exp
    : op=('!' | '-' | '+') body=UnaryExp
    | MethodCallExp
    ;

MethodCallExp returns Exp
    : {MethodCallExp} await='await'? o=ConversionExp op=('!' | '.') m=IDENTIFIER '(' (args+=Exp ( ',' args+=Exp)* )? ')'
    | GetExp
    ;

GetExp returns Exp
    : {GetExp} future=PrimaryExp '.get'
    | ConversionExp
    ;

ConversionExp returns Exp
    : PrimaryExp ({ConversionExp.body=current} op=('implements' | 'as') i=QualifiedTypeIdentifier )?
    ;

PrimaryExp returns Exp
    :  '(' Exp ')'
    | NewExp
    | OriginalCallExp
    | CaseExp
    | LetExp
    | IfExp
    | FunctionAppExp
    | VariadicFunctionAppExp
    | PartialFunctionAppExp
    | ConstructorAppExp
    | TemplateStringExp
    | AtomicExp
    ;

AtomicExp returns Exp
    : {IntLiteral} value=INTLITERAL
    | {FloatLiteral} value=FLOATLITERAL
    | {StringLiteral} value=STRINGLITERAL
    | VarOrFieldExp
    | {ThisExp} 'this'
    | {NullLiteral} 'null'
    ;

VarOrFieldExp returns Exp
    : {VarOrFieldExp} (hasThis?='this' '.')? name=IDENTIFIER
    ;

// Types

TypeUse : ann=Annotations type=TypeUseNoAnnotations ;

// We use TypeUseNoAnnotations for parameters and methods so
// annotations are parsed as part of the method / parameter, not its
// type.
TypeUseNoAnnotations
    : name=QualifiedTypeIdentifier
        ('<' params+=TypeUse (',' params+=TypeUse)* '>')?
    ;

// Terminals

terminal ML_COMMENT : '/*' -> '*/';
terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS: (' '|'\t'|'\r'|'\n')+;

terminal fragment SMALLLETTER : 'a'..'z' ;
terminal fragment CAPITALLETTER : 'A'..'Z' ;

terminal DIGIT : '0'..'9' ;

// "Note: It is generally not a good idea to implement floating point literals
// with terminal rules. You should use data type rules instead due to possible
// shadowing problems explained above."
// https://www.eclipse.org/Xtext/documentation/301_grammarlanguage.html

// But if we use a datatype rule, 'e' and 'E' become reserved words and,
// hence, unavailable as variable names.  Just be careful to define floats
// before ints so they don't get shadowed by the greedy lexer.
terminal FLOATLITERAL returns ecore::EFloat
    : DIGIT* '.' DIGIT+ (("e" | "E" | "e+" | "E+" | "e-" | "E-") DIGIT+)?
    ;

terminal INTLITERAL returns ecore::EInt : DIGIT+ ;

terminal STRINGLITERAL
    : '"' ( '\\' ('"' | '\\' | 't' | 'n' | 'r') | !('"' | '\\'))* '"'
    ;

terminal fragment TEMPLATESTRING_INNER
    : '\\' ('`' | '$')
    | !('`' | '$')
    ;

terminal TEMPLATESTRINGLITERAL : '`' TEMPLATESTRING_INNER* '`' ;

terminal TEMPLATESTRINGSTART
    : '`' TEMPLATESTRING_INNER* '$'
    ;

terminal TEMPLATESTRINGINBETWEEN
    : '$' TEMPLATESTRING_INNER* '$'
    ;
terminal TEMPLATESTRINGEND
    : '$' TEMPLATESTRING_INNER* '`'
    ;


terminal IDENTIFIER : SMALLLETTER (CAPITALLETTER|SMALLLETTER|'_'|DIGIT)* ;

terminal TYPE_IDENTIFIER : CAPITALLETTER (CAPITALLETTER|SMALLLETTER|'_'|DIGIT)* ;

QualifiedIdentifier returns ecore::EString : (TYPE_IDENTIFIER '.')* IDENTIFIER ;
QualifiedTypeIdentifier returns ecore::EString : (TYPE_IDENTIFIER '.')* TYPE_IDENTIFIER ;

AnyIdentifier returns ecore::EString
    : QualifiedIdentifier
    | QualifiedTypeIdentifier
    ;

// Local Variables:
// mode: antlr
// End:
