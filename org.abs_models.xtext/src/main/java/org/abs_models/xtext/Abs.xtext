grammar org.abs_models.xtext.Abs hidden(WS,ML_COMMENT,SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate abs "http://www.abs_models.org/xtext/Abs"

// * Naming conventions
//
// This file is used to create Java class definitions.  Rule names become
// class names, attribute names become setter and getter methods.  We choose
// identifiers in this file with the aim of creating pleasant Java code.
// Also, in the interest of autocompletion and IDE class browsing, we spell
// out words instead of using abbreviations.
//
// - Use whole words: "Expression" instead of "Expr" or "Exp", "Declaration"
//   instead of "Decl".
//
// - Begin rule names with uppercase, attribute names with lowercase.
//
// - Capitalize nouns in rule names.  Be inspired by the existing Java class
//   naming conventions.
//
// - Capitalize nouns in attribute names ("usedTraits" not "usedtraits").  For
//   compound nouns, choose which ones to capitalize with taste ("modulename"
//   not "moduleName" but "typeParameter" not "typeparameter").
//
// Break the above rules with conviction and good taste.
//
// - A special case: boolean rules ("star?=’*’") are converted into boolean
//   methods with "is" prefix ("isStar()").  This cannot be circumvented, even
//   when we’d like to have a method "hasStar()" instead.  Make the best of
//   this behavior.
//

CompilationUnit
    : {CompilationUnit} (modules+=ModuleDeclaration)* (deltas+=DeltaDeclaration)*
        productline=ProductlineDeclaration?
        products+=ProductDeclaration*
        ( rootFeatures+=MTVLFeatureRoot
        | featureExtensions+=MTVLFeatureExtension)*
    ;

ModuleDeclaration
    : 'module' name=QualifiedTypeIdentifier ';'
        (exports+=ModuleExport | imports+=ModuleImport)*
        (declarations+=Declaration)*
        ( mainblockAnnotations=Annotations main?='{' (mainblockStatements+=Stmt)* '}')?
    ;

ModuleExport
    : 'export'
        ( star?='*' | identifiers+=AnyIdentifier (',' identifiers+=AnyIdentifier)*)
        ( 'from' modulename=QualifiedTypeIdentifier )?
        ';'
    ;

ModuleImport
    : 'import'
        (( star?='*' 'from' modulename=QualifiedTypeIdentifier )
        | (identifiers+=AnyIdentifier (',' identifiers+=AnyIdentifier)*
                ( 'from' modulename=QualifiedTypeIdentifier )?
            ))
        ';'
    ;

// Annotations

Annotation: (id=TYPE_IDENTIFIER ':')? value=Exp ;

Annotations: {Annotations} ( '[' annotations+=Annotation (',' annotations+=Annotation)* ']')* ;

// Declarations

Declaration
    : annotations=Annotations
        ( datatypeDeclaration=DataTypeDeclaration
        | typesynonymDeclaration=TypeSynonymDeclaration
        | exceptionDeclaration=ExceptionDeclaration
        | functionDeclaration=FunctionDeclaration
        | traitDeclaration=TraitDeclaration
        | interfaceDeclaration=InterfaceDeclaration
        | classDeclaration=ClassDeclaration
        )
    ;

DataTypeDeclaration
    : 'data' name=TYPE_IDENTIFIER
        ('<' typeParameters+=TYPE_IDENTIFIER (',' typeParameters+=TYPE_IDENTIFIER)* '>')?
        ('=' constructors+=DataConstructorDeclaration ('|' constructors+=DataConstructorDeclaration)* )?
        ';'
    ;

DataConstructorDeclaration : name=TYPE_IDENTIFIER ('(' arguments+=DataConstructorParameter (',' arguments+=DataConstructorParameter)* ')')? ;

DataConstructorParameter : type=TypeUse (name=IDENTIFIER)? ;

TypeSynonymDeclaration : 'type' name=TYPE_IDENTIFIER '=' type=TypeUse ';' ;

ExceptionDeclaration
    : 'exception' name=TYPE_IDENTIFIER
        ('(' arguments+=DataConstructorParameter (',' arguments+=DataConstructorParameter)* ')')? ';'
    ;

FunctionDeclaration
    : 'def' resulttype=TypeUse name=IDENTIFIER
        ('<' typeParameters+=TYPE_IDENTIFIER (',' typeParameters+=TYPE_IDENTIFIER)* '>')?
        ( '(' (functionArguments+=IDENTIFIER (',' functionArguments+=IDENTIFIER)*)? ')')?
        '(' (arguments+=Parameter (',' arguments+=Parameter)* )? ')'
        '=' (builtin?='builtin' | body=Exp)
        ';'
    ;

TraitDeclaration : 'trait' name=TYPE_IDENTIFIER '=' traitExpression=TraitExp ;

TraitExp : basicExpression=BasicTraitExp traitOperations+=TraitOp* ;

BasicTraitExp
    : MethodSet?='{' methods+=MethodDeclaration* '}'
    | methods+=MethodDeclaration
    | ref=TYPE_IDENTIFIER
    ;

TraitOp
    : 'removes'
        ( RemoveMethodModifier?='{' ( removedSignatures+=MethodSignature ';' )* '}'
        | removedSignatures+=MethodSignature ';' )
    | 'adds' addedExpression=BasicTraitExp
    | 'modifies' modifiedExpression=BasicTraitExp
    ;

InterfaceDeclaration
    : 'interface' name=TYPE_IDENTIFIER
        ('extends' superinterfaces+=QualifiedTypeIdentifier (',' superinterfaces+=QualifiedTypeIdentifier)* )?
        '{' (methods+=MethodSignature ';' )* '}'
    ;

MethodSignature
    : annotations=Annotations resulttype=TypeUseNoAnnotations name=IDENTIFIER
        '(' ( arguments+=Parameter (',' arguments+=Parameter)* )? ')'
    ;

ClassDeclaration
    : 'class' name=TYPE_IDENTIFIER
        ( '(' ( arguments+=Parameter (',' arguments+=Parameter)* )? ')' )?
        ( 'implements' interfaces+=QualifiedTypeIdentifier (',' interfaces+=QualifiedTypeIdentifier)* )?
        '{'
        (fields+=FieldDeclaration ';')*
        ( '{' initblockstmts+=Stmt* '}' )?
        ( 'recover' '{' (recoverbranches+=SwitchStmtBranch)* '}' )?
        ( 'uses' usedTraits+=TraitExp ';' )*
        (methods+=MethodDeclaration)*
        '}'
    ;

FieldDeclaration
    : annotations=Annotations type=TypeUseNoAnnotations name=IDENTIFIER
        (hasInit?='=' init=Exp)?
    ;

MethodDeclaration
    : annotations=Annotations resulttype=TypeUseNoAnnotations name=IDENTIFIER
        // Our JastAdd AST has an embedded MethodSig inside MethodDeclaration while
        // in xtext we just parse name etc. directly.  `sigEndPosition' is
        // used to calculate the end location of that embedded node.
        '(' (arguments+=Parameter (',' arguments+=Parameter)* )? sigEndPosition=')'
        '{' (statements+=Stmt)* '}'
    ;

Parameter : annotations=Annotations type=TypeUseNoAnnotations name=IDENTIFIER ;

// Statements

Stmt : Annotations
        ( {VarDeclStmt.annotations=current}
            type=TypeUseNoAnnotations name=IDENTIFIER ( '=' init=Exp )? ';'
        | {AssignStmt.annotations=current}
            lhs=VarOrFieldExp '=' expression=Exp ';'
        | {SkipStmt.annotations=current}
             'skip' ';'
        | {ReturnStmt.annotations=current}
            'return' expression=Exp ';'
        | {AssertStmt.annotations=current}
            'assert' expression=Exp ';'
        | {Block.annotations=current}
            '{' (stmts+=Stmt)* '}'
        | {IfStmt.annotations=current}
            'if' '(' condition=Exp ')' consequence=Stmt (=>'else' alternate=Stmt)?
        | {WhileStmt.annotations=current}
            'while' '(' condition=Exp ')' body=Stmt
        | {ForeachStmt.annotations=current}
            'foreach' '(' loopvar=IDENTIFIER 'in' list=Exp ')' body=Stmt
        | {TryCatchFinallyStmt.annotations=current}
            'try' body=Stmt
            'catch' (( '{' (branches+=SwitchStmtBranch)* '}') | branches+=SwitchStmtBranch)
            (=> 'finally' finally=Stmt)?
        // await is parsed as an expression; this way we catch both "await
        // o!m()" and "await f?;" in one syntax rule.  We disallow certain
        // combinations of guards in validation -- see AbsValidator.checkSideEffectExpressionAllowed, AbsValidator.checkNoMethodCallInSubguard.
        | {SuspendStmt.annotations=current}
            'suspend' ';'
        | {DurationStmt.annotations=current}
            'duration' '(' min=Exp ',' max=Exp ')' ';'
        | {ThrowStmt.annotations=current}
            'throw' exception=Exp ';'
        | {DieStmt.annotations=current}
            'die' exception=Exp ';'
        | {MoveCogToStmt.annotations=current}
            'movecogto' target=Exp ';'
        | {ExpStmt.annotations=current}
            expression=Exp ';'
        | {SwitchStmt.annotations=current}
            'switch' '(' condition=Exp ')' '{' (branches+=SwitchStmtBranch)* '}'
        )
    ;

Guard : AndGuard ;

AndGuard returns Guard
    : SingleGuard ({AndGuard.left=current} '&' right=SingleGuard)*
    ;

SingleGuard returns Guard
    : {ExpGuard} expression=Exp claim?='?'?
    | {DurationGuard} 'duration' '(' min=Exp ',' max=Exp ')'
    ;

SwitchStmtBranch : pattern=Pattern '=>' body=Stmt ;

Pattern
    : {WildcardPattern} '_'
    | {IntLiteralPattern} value=INTLITERAL
    | {StringLiteralPattern} value=STRINGLITERAL
    | {FloatLiteralPattern} value=FLOATLITERAL
    | {VariablePattern} value=IDENTIFIER
    | {ConstructorPattern} name=QualifiedTypeIdentifier ( '(' (arguments+=Pattern (',' arguments+=Pattern)* )? ')' )?
    ;

// Expressions

// KLUDGE: I did not manage to express the separation of side-effect and pure
// expressions in the Xtext parser in the way that antlr4 did it -- having
// PureExp as prefixes in GetExp, AsyncCallExp and SyncCallExp did not lead to
// compile-time warnings for these expressions but mis-parsed them
// nevertheless.

// KLUDGE: the expression grammar fragment is not LL(2) (although
// Exp by itself is) -- we turned on backtracking in
// `GenerateAbs.mwe2' for now.
// TODO: check if this is still necessary now that we merged EffExp and PureExp
Exp
    : OrExp
    ;

// See http://www.eclipse.org/Xtext/documentation/307_special_languages.html#expressions

OrExp returns Exp
    : AndExp ({OrExp.left=current} '||' right=AndExp)*
    ; // left-assoc

AndExp returns Exp
    : EqExp ({AndExp.left=current} '&&' right=EqExp)*
    ; // left-assoc

EqExp returns Exp
    : CompareExp
        (( {EqExp.left=current} '=='
         | {NotEqExp.left=current} '!=')
        right=CompareExp)?
    ; // non-assoc

CompareExp returns Exp
    : PlusMinusExp
        (( {LTExp.left=current} '<'
         | {GTExp.left=current} '>'
         | {LTEQExp.left=current} '<='
         | {GTEQExp.left=current} '>=')
        right=PlusMinusExp)?
    ; // non-assoc

PlusMinusExp returns Exp
    : MulDivModExp
        (( {PlusExp.left=current} '+'
         | {MinusExp.left=current} '-')
        right=MulDivModExp)*
    ; // left-assoc

MulDivModExp returns Exp
    : MethodCallExp
        (( {MulExp.left=current} '*'
         | {DivExp.left=current}'/'
         | {ModExp.left=current} '%')
        right=MethodCallExp)*
    ; // left-assoc

MethodCallExp returns Exp
// "await o!m()" is parsed as an AwaitExp with an ExpGuard containing a
// MethodCallExp instead of a MethodCallExp with an "await" prefix -- see also
// AbsValidator where we filter out invalid syntaxes, and XtextToJastAdd where
// we disambiguate between AwaitStmt and AwaitAsyncCall; the code there is not
// pretty.
//
// But: “In general, a good practice in Xtext DSL implementations is to keep
// the grammar simple.  It is better to have a loose grammar and a strict
// validation phase (loose grammar, strict validation, see the presentation
// Zarnekow 2012).” (Bettini 2016, pg. 207)
    : GetExp ({MethodCallExp.target=current} operator=('!' | '.') methodname=IDENTIFIER '(' (arguments+=Exp ( ',' arguments+=Exp)* )? ')' )?
    ;

GetExp returns Exp
    : ConversionExp ({GetExp.futureExpression=current} '.' 'get' )?
    ;

ConversionExp returns Exp
    : PrimaryExp
        (( {ImplementsExp.body=current} 'implements'
         | {AsExp.body=current} 'as' )
        interface=QualifiedTypeIdentifier )?
    ;

PrimaryExp returns Exp
    :  '(' Exp ')'
    | UnaryExp
    | AwaitExp
    | NewExp
    | OriginalCallExp
    | CaseExp
    | LetExp
    | WhenExp
    | FunctionAppExp
    | VariadicFunctionAppExp
    | ConstructorAppExp
    | TemplateStringExp
    | AtomicExp
    ;

UnaryExp returns Exp
    : ( '!' PrimaryExp {NotExp.body=current}
      | '-' PrimaryExp {NegExp.body=current}
      // | '+' Exp {PosExp.body=current}
    )
    ;

AwaitExp returns Exp : {AwaitExp} 'await' guard=Guard ;

NewExp returns Exp :
        {NewExp} 'new' (local?='local')? classname=QualifiedTypeIdentifier '('  (arguments+=Exp ( ',' arguments+=Exp)* )? ')'
    ;

OriginalCallExp returns Exp : {OriginalCallExp} (( delta=TYPE_IDENTIFIER | core?='core' ) '.')? 'original' '(' (arguments+=Exp ( ',' arguments+=Exp)* )? ')' ;

CaseExp returns Exp
    : {CaseExp} 'case' condition=Exp '{' (casebranches+=CaseExpBranch)* '}'
    ;

CaseExpBranch
    : pattern=Pattern '=>' expression=Exp ';'
    ;

LetExp returns Exp
    : {LetExp} 'let' '('? variables+=Parameter ')'? '=' exps+=Exp
        (',' '('? variables+=Parameter ')'? '=' exps+=Exp)*
        'in' body=Exp
    ;

WhenExp returns Exp
    : {WhenExp} 'when' condition=Exp 'then' consequence=Exp 'else' alternate=Exp
    ;

FunctionAppExp returns Exp
    : {FunctionAppExp} name=QualifiedIdentifier
        ( '(' functionArguments+=PartialFunctionParam (',' functionArguments+=PartialFunctionParam )* ')' )?
        '(' (arguments+=Exp ( ',' arguments+=Exp)* )? ')'
    ;

PartialFunctionParam
    : name=QualifiedIdentifier
    | '(' ( parameters+=Parameter (',' parameters+=Parameter)* )? ')' "=>" body=Exp
    ;

VariadicFunctionAppExp returns Exp
    : {VariadicFunctionAppExp} name=QualifiedIdentifier '[' (arguments+=Exp ( ',' arguments+=Exp)* )? ']'
    ;

ConstructorAppExp returns Exp
    : {ConstructorAppExp} name=QualifiedTypeIdentifier ( '(' ( arguments+=Exp ( ',' arguments+=Exp)* )? ')' )?
    ;

TemplateStringExp returns Exp
    : {TemplateStringSimpleExp} string=TEMPLATESTRINGLITERAL
    | {TemplateStringExp} startString=TEMPLATESTRINGSTART firstExpression=Exp
        (betweenStrings+=TEMPLATESTRINGINBETWEEN exps+=Exp)*
        endString=TEMPLATESTRINGEND
    ;

AtomicExp returns Exp
    : {IntLiteral} value=INTLITERAL
    | {FloatLiteral} value=FLOATLITERAL
    | {StringLiteral} value=STRINGLITERAL
    | VarOrFieldExp
    | {ThisExp} 'this'
    | {NullLiteral} 'null'
    ;

VarOrFieldExp returns Exp
    : {VarOrFieldExp} (field?='this' '.')? name=IDENTIFIER
    ;

// Types

TypeUse : annotations=Annotations type=TypeUseNoAnnotations ;

// We use TypeUseNoAnnotations for parameters and methods so
// annotations are parsed as part of the method / parameter, not its
// type.
TypeUseNoAnnotations
    : name=QualifiedTypeIdentifier
        ('<' parameters+=TypeUse (',' parameters+=TypeUse)* '>')?
    ;

// Terminals

terminal ML_COMMENT : '/*' -> '*/';
terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS: (' '|'\t'|'\r'|'\n')+;

terminal fragment SMALLLETTER : 'a'..'z' ;
terminal fragment CAPITALLETTER : 'A'..'Z' ;

terminal DIGIT : '0'..'9' ;

// "Note: It is generally not a good idea to implement floating point literals
// with terminal rules. You should use data type rules instead due to possible
// shadowing problems explained above."
// https://www.eclipse.org/Xtext/documentation/301_grammarlanguage.html

// But if we use a datatype rule, 'e' and 'E' become reserved words and,
// hence, unavailable as variable names.  Just be careful to define floats
// before ints so they don't get shadowed by the greedy lexer.
terminal FLOATLITERAL returns ecore::EDouble
    : DIGIT* '.' DIGIT+ (("e" | "E" | "e+" | "E+" | "e-" | "E-") DIGIT+)?
    ;

terminal INTLITERAL returns ecore::EBigInteger : DIGIT+ ;

terminal STRINGLITERAL
    : '"' ( '\\' ('"' | '\\' | 't' | 'n' | 'r') | !('"' | '\\'))* '"'
    ;

terminal fragment TEMPLATESTRING_INNER
    : '\\' ('`' | '$')
    | !('`' | '$')
    ;

terminal TEMPLATESTRINGLITERAL : '`' TEMPLATESTRING_INNER* '`' ;

terminal TEMPLATESTRINGSTART
    : '`' TEMPLATESTRING_INNER* '$'
    ;

terminal TEMPLATESTRINGINBETWEEN
    : '$' TEMPLATESTRING_INNER* '$'
    ;
terminal TEMPLATESTRINGEND
    : '$' TEMPLATESTRING_INNER* '`'
    ;


terminal IDENTIFIER : SMALLLETTER (CAPITALLETTER|SMALLLETTER|'_'|DIGIT)* ;

terminal TYPE_IDENTIFIER : CAPITALLETTER (CAPITALLETTER|SMALLLETTER|'_'|DIGIT)* ;

QualifiedIdentifier returns ecore::EString : (TYPE_IDENTIFIER '.')* IDENTIFIER ;
QualifiedTypeIdentifier returns ecore::EString : (TYPE_IDENTIFIER '.')* TYPE_IDENTIFIER ;

AnyIdentifier returns ecore::EString
    : QualifiedIdentifier
    | QualifiedTypeIdentifier
    ;

// ========== end of Core ABS ==========

// Deltas

DeltaDeclaration
    : 'delta' name=TYPE_IDENTIFIER
        ( '(' ( arguments+=DeltaParameter (',' arguments+=DeltaParameter)* )? ')' )?
        ';'
        // TODO: multiple in the antlr grammar but the AST only supports one
        // instance of this
        ('uses' usedModulenames+=QualifiedTypeIdentifier ';')*
        (modifiers+=DeltaModuleModifier)*
    ;

DeltaParameter
    : normalParameter=Parameter
    | ( classModifier=QualifiedTypeIdentifier condition=DeltaCondition )
    ;

DeltaCondition
    : 'hasField' deltaFieldCondition=FieldDeclaration
    | 'hasMethod' deltaMethodCondition=MethodSignature
    | 'hasInterface' deltaInterfaceCondition=QualifiedTypeIdentifier
    ;

DeltaModuleModifier
    : 'adds'
        ( addedDeclaration=Declaration
        | addedImport=ModuleImport
        | addedExport=ModuleExport)
    | 'removes'
        ( 'class' removedClassName=QualifiedTypeIdentifier ';'
        | 'interface' removedInterfaceName=QualifiedTypeIdentifier ';')
    | 'modifies'
        ( 'class' modifiedClassName=QualifiedTypeIdentifier
            ('adds' addedInterfaces+=QualifiedTypeIdentifier
                (',' addedInterfaces+=QualifiedTypeIdentifier)*)?
            ('removes' removedInterfaces+=QualifiedTypeIdentifier
                (',' removedInterfaces+=QualifiedTypeIdentifier)*)?
            '{' (classModifiers+=ClassModifier)* '}'
        | 'interface' modifiedInterfaceName=QualifiedTypeIdentifier
            '{' (interfaceModifiers+=InterfaceModifier)* '}'
        | modifiedTypesyn=TypeSynonymDeclaration
        | modifiedDatatype=DataTypeDeclaration
        )
    ;

ClassModifier
    : 'adds'
        ( addedField=FieldDeclaration ';'
        | '{' addedMethods+=MethodDeclaration* '}'
        | addedMethods+=MethodDeclaration
        | addedTrait=TYPE_IDENTIFIER)
    | 'removes'
        ( removedField=FieldDeclaration ';'
        | '{' ( removedMethods+=MethodSignature ';' )* '}'
        | removedMethods+=MethodSignature ';' )
    | 'modifies'
        ( modifiedMethods+=MethodDeclaration
        | '{' modifiedMethods+=MethodDeclaration* '}'
        | modifiedTrait=TYPE_IDENTIFIER
        )
    ;

InterfaceModifier
    : 'adds' addedMethod=MethodSignature ';'
    | 'removes' removedMethod=MethodSignature ';'
    ;

// Productline

ProductlineDeclaration
    : 'productline' name=TYPE_IDENTIFIER ';'
        'features' features+=ProductFeature (',' features+=ProductFeature)* ';'
        deltaClauses+=ProductlineDeltaClause*
    ;

ProductFeature
// allow writing Feat' to refer to the intermediate feature "$feat"
    : name=TYPE_IDENTIFIER p?='\''?
        ('{' attributeAssignments+=AttributeAssignment (',' attributeAssignments+=AttributeAssignment)* '}')?
    ;

AttributeAssignment : name=IDENTIFIER '=' value = AttributeAssignmentValue ;

AttributeAssignmentValue
    : {AttributeAssignmentValue_Int} value=INTLITERAL
    | {AttributeAssignmentValue_Bool} value=TYPE_IDENTIFIER
    | {AttributeAssignmentValue_String} value=STRINGLITERAL
    ;

ProductlineDeltaClause
    : 'delta' name=TYPE_IDENTIFIER
        ('(' parameters+=DeltaClauseParam (',' parameters+=DeltaClauseParam)* ')')?
        ('after' afterIds+=TYPE_IDENTIFIER (',' afterIds+=TYPE_IDENTIFIER)* )?
        ('from' fromCondition=DeltaClauseApplicationClause)?
        (('when' | 'to') whenCondition=DeltaClauseApplicationClause)?
        ';'
    ;

DeltaClauseParam
// CID | FID.aid | CONSTANT
// The following comment copied from ABS.g4, which copied from ABS.parser:
// TODO: accept feature, attributes, or constants (DataExp)
    : {DeltaClauseParam_Int} intParameter=INTLITERAL
    | {DeltaClauseParam_Id} idParameter=TYPE_IDENTIFIER ('.' fidaidParameter=IDENTIFIER)?
    ;

DeltaClauseApplicationClause : DeltaClauseApplicationClauseOr ;

DeltaClauseApplicationClauseOr returns DeltaClauseApplicationClause
    : DeltaClauseApplicationClauseAnd ({DeltaClauseApplicationClauseOr.left = current} '||' right=DeltaClauseApplicationClauseAnd)* ;

DeltaClauseApplicationClauseAnd returns DeltaClauseApplicationClause
    : DeltaClauseApplicationClausePrimary ({DeltaClauseApplicationClauseAnd.left = current} '&&' right=DeltaClauseApplicationClausePrimary)* ;

DeltaClauseApplicationClausePrimary returns DeltaClauseApplicationClause
    : '!' not=DeltaClauseApplicationClausePrimary
    | '(' paren=DeltaClauseApplicationClause ')'
    | featureName=TYPE_IDENTIFIER
    ;

// Products

ProductDeclaration
    : 'product' name=TYPE_IDENTIFIER
        ( '(' ( features+=ProductFeature (',' features+=ProductFeature)* )? ')' ';'
        | '=' expression=ProductExpression ';' )
    ;

ProductExpression : ProductExprDifference ;

ProductExprDifference returns ProductExpression
    : ProductExprUnion ({ProductExprDifference.left = current} '-' right=ProductExprUnion)*
    ;

ProductExprUnion returns ProductExpression
    : ProductExprIntersect ({ProductExprUnion.left = current} '||' right=ProductExprIntersect)*
    ;

ProductExprIntersect returns ProductExpression
    : ProductExprPrimary ({ProductExprIntersect.left = current} '&&' right=ProductExprPrimary)*
    ;

ProductExprPrimary returns ProductExpression
    : '{' features+=ProductFeature (',' features+=ProductFeature)* '}'
    | prodname=TYPE_IDENTIFIER
    | '(' paren=ProductExpression ')'
    ;

// Feature Model


// The following rules are translations of the corresponding antlr rules and
// differ from the grammar in the manual in some places.
MTVLFeatureRoot
    : 'root' name=TYPE_IDENTIFIER
        (
            '{'
            group=MTVLFeatureGroup?
            (attributes+=MTVLAttributeDeclaration | constraints+=MTVLConstraint)*
            '}'
        )?
    ;

MTVLFeatureDeclaration
// same as MTVLFeatureRoot without the ’root’ keyword in front
    : name=TYPE_IDENTIFIER
        (
            '{'
            group=MTVLFeatureGroup?
            (attributes+=MTVLAttributeDeclaration | constraints+=MTVLConstraint)*
            '}'
        )?
    ;

MTVLFeatureExtension
    : 'extension' name=TYPE_IDENTIFIER
        '{'
        group=MTVLFeatureGroup?
        (attributes+=MTVLAttributeDeclaration | constraints+=MTVLConstraint)*
        '}'
    ;

MTVLFeatureGroup
    : 'group'
        ( allof?='allof'
        | oneof?='oneof'
        | '[' lower=INTLITERAL '..' upper=MTVLIntLimit ']'
        )
        '{'
        children+=MTVLChildFeature (',' children+=MTVLChildFeature)*
        '}'
    ;

MTVLChildFeature : opt?='opt'? feature=MTVLFeatureDeclaration ;

MTVLAttributeDeclaration
    : type=TYPE_IDENTIFIER name=IDENTIFIER
        ('in'
            ( interval?='[' lower=MTVLIntLimit '..' upper=MTVLIntLimit ']'
            | set?='{' content+=MTVLIntValue (',' content+=MTVLIntValue)* '}')
        )?
        ';'
    ;

MTVLIntLimit : star?='*' | minus?='-'? value=INTLITERAL ;

MTVLIntValue : minus?='-'? value=INTLITERAL ;

MTVLConstraint returns MTVLConstraint
    : 'ifin' {MTVLIfInConstraint} ':' expression=MTVLConstraintExpression ';'
    | 'ifout' {MTVLIfOutConstraint} ':' expression=MTVLConstraintExpression ';'
    | 'require' {MTVLRequireConstraint} ':' require=TYPE_IDENTIFIER ';'
    | 'exclude' {MTVLExcludeConstraint} ':' exclude=TYPE_IDENTIFIER ';'
    | {MTVLIfInConstraint} expression=MTVLConstraintExpression ';'
    ;

MTVLConstraintExpression : MTVLConstraintOrExpression ;

MTVLConstraintOrExpression returns MTVLConstraintExpression
    : MTVLConstraintAndExpression ({MTVLConstraintOrExpression.left=current} '||' right=MTVLConstraintAndExpression)*
    ; // left-assoc

MTVLConstraintAndExpression returns MTVLConstraintExpression
    : MTVLConstraintImplEqvExpression ({MTVLConstraintAndExpression.left=current} '&&' right=MTVLConstraintImplEqvExpression)*
    ; // left-assoc

MTVLConstraintImplEqvExpression returns MTVLConstraintExpression
    : MTVLConstraintEqNeqExpression
        ( ({MTVLConstraintImplExpression.left=current} '->' right=MTVLConstraintEqNeqExpression)
        | ({MTVLConstraintEqvExpression.left=current} '<->' right=MTVLConstraintEqNeqExpression))?
    ; // non-assoc

MTVLConstraintEqNeqExpression returns MTVLConstraintExpression
    : MTVLConstraintCompareExpression
        ( ({MTVLConstraintEqExpression.left=current} '==' right=MTVLConstraintCompareExpression)
        | ({MTVLConstraintNeqExpression.left=current} '!=' right=MTVLConstraintCompareExpression))?
    ; // non-assoc

MTVLConstraintCompareExpression returns MTVLConstraintExpression
    : MTVLConstraintPlusMinusExpression
        ( ({MTVLConstraintLTExpression.left=current} '<' right=MTVLConstraintPlusMinusExpression)
        | ({MTVLConstraintGTExpression.left=current} '>' right=MTVLConstraintPlusMinusExpression)
        | ({MTVLConstraintLTEQExpression.left=current} '<=' right=MTVLConstraintPlusMinusExpression)
        | ({MTVLConstraintGTEQExpression.left=current} '>=' right=MTVLConstraintPlusMinusExpression))?
    ; // non-assoc

MTVLConstraintPlusMinusExpression returns MTVLConstraintExpression
    : MTVLConstraintMulDivModExpression
      ( ({MTVLConstraintPlusExpression.left=current} '+' right=MTVLConstraintMulDivModExpression)
        | ({MTVLConstraintMinusExpression.left=current} '-' right=MTVLConstraintMulDivModExpression))*
    ; // left-assoc

MTVLConstraintMulDivModExpression returns MTVLConstraintExpression
    : MTVLConstraintPrimaryExpression
      ( ({MTVLConstraintMulExpression.left=current} '*' right=MTVLConstraintPrimaryExpression)
        | ({MTVLConstraintDivExpression.left=current} '/' right=MTVLConstraintPrimaryExpression)
        | ({MTVLConstraintModExpression.left=current} '%' right=MTVLConstraintPrimaryExpression))*
    ; // left-assoc

MTVLConstraintPrimaryExpression returns MTVLConstraintExpression
    : '(' parenExpression=MTVLConstraintExpression ')'
    | '-' minusExpression=MTVLConstraintPrimaryExpression
    | '!' negExpression=MTVLConstraintPrimaryExpression
    | intExpression=INTLITERAL
    | idExpression=IDENTIFIER
    | typeExpression=TYPE_IDENTIFIER (dot?='.' dotId=IDENTIFIER)?
    ;

// Local Variables:
// mode: antlr
// End:
